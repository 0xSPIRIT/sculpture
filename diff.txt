diff --git a/bin/.vs/win32_sculpture/v17/.suo b/bin/.vs/win32_sculpture/v17/.suo
index 429bfd2..a941251 100644
Binary files a/bin/.vs/win32_sculpture/v17/.suo and b/bin/.vs/win32_sculpture/v17/.suo differ
diff --git a/bin/.vs/win32_sculpture/v17/Browse.VC.db b/bin/.vs/win32_sculpture/v17/Browse.VC.db
index bc8d062..4098e67 100644
Binary files a/bin/.vs/win32_sculpture/v17/Browse.VC.db and b/bin/.vs/win32_sculpture/v17/Browse.VC.db differ
diff --git a/bin/.vs/win32_sculpture/v17/Browse.VC.db-shm b/bin/.vs/win32_sculpture/v17/Browse.VC.db-shm
index 3414c75..4515d72 100644
Binary files a/bin/.vs/win32_sculpture/v17/Browse.VC.db-shm and b/bin/.vs/win32_sculpture/v17/Browse.VC.db-shm differ
diff --git a/bin/obj/game.obj b/bin/obj/game.obj
index dd2b245..c3a728f 100644
Binary files a/bin/obj/game.obj and b/bin/obj/game.obj differ
diff --git a/bin/obj/main.obj b/bin/obj/main.obj
index 954ea47..0b41335 100644
Binary files a/bin/obj/main.obj and b/bin/obj/main.obj differ
diff --git a/bin/sculpture.dll b/bin/sculpture.dll
index ff60c28..7aa30fb 100644
Binary files a/bin/sculpture.dll and b/bin/sculpture.dll differ
diff --git a/bin/sculpture_temp.dll b/bin/sculpture_temp.dll
index ff60c28..7aa30fb 100644
Binary files a/bin/sculpture_temp.dll and b/bin/sculpture_temp.dll differ
diff --git a/bin/vc140.pdb b/bin/vc140.pdb
index f3aeba7..d352269 100644
Binary files a/bin/vc140.pdb and b/bin/vc140.pdb differ
diff --git a/bin/win32_sculpture.exe b/bin/win32_sculpture.exe
index eb5a88a..389a1dc 100644
Binary files a/bin/win32_sculpture.exe and b/bin/win32_sculpture.exe differ
diff --git a/bin/win32_sculpture.pdb b/bin/win32_sculpture.pdb
index 466178c..d7bc343 100644
Binary files a/bin/win32_sculpture.pdb and b/bin/win32_sculpture.pdb differ
diff --git a/src/assets.c b/src/assets.c
index 524813c..6d7147b 100644
--- a/src/assets.c
+++ b/src/assets.c
@@ -92,11 +92,9 @@ void render_targets_init(SDL_Window *window,
                          int width, // In screen coords, not game coords.
                          struct Level *levels,
                          struct Textures *textures) {
-    const int amount = RENDER_TARGET_COUNT;
-    
     for (int lvl = 0; lvl < LEVEL_COUNT; lvl++) {
         struct Level *l = &levels[lvl];
-        for (int i = 0; i < amount; i++) {
+        for (int i = 0; i < RENDER_TARGET_COUNT; i++) {
             if (i == 1) {
                 textures->render_targets[lvl][i] = new_render_target(width, GUI_H);
                 continue;
diff --git a/src/assets.h b/src/assets.h
index 0715346..0345859 100644
--- a/src/assets.h
+++ b/src/assets.h
@@ -13,12 +13,12 @@
 
 // Index into textures.render_targets[]
 enum {
-    TARGET_GLOBAL, // The main render target
-    TARGET_GUI_TOOLBAR, // The render target showing the tool buttons
-    TARGET_KNIFE,
-    TARGET_BLOB_HAMMER,
-    TARGET_CHISEL_BLOCKER,
-    TARGET_CHISEL // Use the same render target for each chisel.
+    RENDER_TARGET_GLOBAL, // The main render target
+    RENDER_TARGET_GUI_TOOLBAR, // The render target showing the tool buttons
+    RENDER_TARGET_KNIFE,
+    RENDER_TARGET_BLOB_HAMMER,
+    RENDER_TARGET_CHISEL_BLOCKER,
+    RENDER_TARGET_CHISEL // Use the same render target for each chisel.
 };
 
 // Only contains textures!
diff --git a/src/blob_hammer.c b/src/blob_hammer.c
index 55f4734..77611a9 100644
--- a/src/blob_hammer.c
+++ b/src/blob_hammer.c
@@ -144,10 +144,10 @@ void blob_hammer_update_texture() {
     struct Blob_Hammer *blob_hammer = &gs->blob_hammer;
     
     SDL_Texture *prev_target = SDL_GetRenderTarget(gs->renderer);
-    SDL_SetTextureBlendMode(RenderTarget(gs, TARGET_BLOB_HAMMER), SDL_BLENDMODE_BLEND);
+    SDL_SetTextureBlendMode(RenderTarget(gs, RENDER_TARGET_BLOB_HAMMER), SDL_BLENDMODE_BLEND);
     
-    Assert(gs->window, RenderTarget(gs, TARGET_BLOB_HAMMER));
-    SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, TARGET_BLOB_HAMMER));
+    Assert(gs->window, RenderTarget(gs, RENDER_TARGET_BLOB_HAMMER));
+    SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, RENDER_TARGET_BLOB_HAMMER));
 
     SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 0);
     SDL_RenderClear(gs->renderer);
@@ -182,5 +182,5 @@ void blob_hammer_draw() {
     struct Blob_Hammer *blob_hammer = &gs->blob_hammer;
     
     blob_hammer_update_texture();
-    SDL_RenderCopy(gs->renderer, RenderTarget(gs, TARGET_BLOB_HAMMER), NULL, NULL);
+    SDL_RenderCopy(gs->renderer, RenderTarget(gs, RENDER_TARGET_BLOB_HAMMER), NULL, NULL);
 }
diff --git a/src/chisel.c b/src/chisel.c
index a682a5c..23637de 100644
--- a/src/chisel.c
+++ b/src/chisel.c
@@ -220,10 +220,10 @@ void chisel_update_texture() {
     struct Chisel *chisel = gs->chisel;
 
     SDL_Texture *prev_target = SDL_GetRenderTarget(gs->renderer);
-    SDL_SetTextureBlendMode(RenderTarget(gs, TARGET_CHISEL), SDL_BLENDMODE_BLEND);
+    SDL_SetTextureBlendMode(RenderTarget(gs, RENDER_TARGET_CHISEL), SDL_BLENDMODE_BLEND);
     
-    Assert(gs->window, RenderTarget(gs, TARGET_CHISEL));
-    SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, TARGET_CHISEL));
+    Assert(gs->window, RenderTarget(gs, RENDER_TARGET_CHISEL));
+    SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, RENDER_TARGET_CHISEL));
 
     SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 0);
     SDL_RenderClear(gs->renderer);
@@ -288,7 +288,7 @@ void chisel_update_texture() {
     // PROBLEM AREA!
     int w, h;
 
-    SDL_QueryTexture(RenderTarget(gs, TARGET_CHISEL), NULL, NULL, &w, &h);
+    SDL_QueryTexture(RenderTarget(gs, RENDER_TARGET_CHISEL), NULL, NULL, &w, &h);
     Assert(gs->window, w == gs->gw && h == gs->gh);
     
     SDL_RenderReadPixels(gs->renderer, NULL, 0, chisel->pixels, 4*gs->gw);
@@ -300,7 +300,7 @@ void chisel_draw() {
     struct Chisel *chisel = gs->chisel;
 
     chisel_update_texture();
-    SDL_RenderCopy(gs->renderer, RenderTarget(gs, TARGET_CHISEL), NULL, NULL);
+    SDL_RenderCopy(gs->renderer, RenderTarget(gs, RENDER_TARGET_CHISEL), NULL, NULL);
 
     // Draw the highlights for blobs now.
     if (DRAW_CHISEL_HIGHLIGHTS) {
diff --git a/src/chisel.h b/src/chisel.h
index b6a7a12..55a71da 100644
--- a/src/chisel.h
+++ b/src/chisel.h
@@ -7,7 +7,7 @@
 #define CHISEL_TIME 0 /* The amount of frames the chisel moves. 0 = instant */
 #define CHISEL_COOLDOWN 3
 #define CHISEL_FORGIVING_AIM false // Do we check for surrounding cells?
-#define DRAW_CHISEL_HIGHLIGHTS true
+#define DRAW_CHISEL_HIGHLIGHTS false
 
 struct Chisel_Hammer {
 	int state;
diff --git a/src/chisel_blocker.c b/src/chisel_blocker.c
index ebe944d..c1affa3 100644
--- a/src/chisel_blocker.c
+++ b/src/chisel_blocker.c
@@ -21,7 +21,7 @@ void chisel_blocker_init() {
 
     chisel_blocker->side = 1;
 
-    SDL_SetTextureBlendMode(RenderTarget(gs, TARGET_CHISEL_BLOCKER), SDL_BLENDMODE_BLEND);
+    SDL_SetTextureBlendMode(RenderTarget(gs, RENDER_TARGET_CHISEL_BLOCKER), SDL_BLENDMODE_BLEND);
     chisel_blocker->pixels = push_memory(gs->persistent_memory, gs->gw*gs->gh, sizeof(Uint32));
 }
 
@@ -63,7 +63,7 @@ void chisel_blocker_tick() {
 
     /* SDL_ShowCursor(1); */
     if (SDL_GetCursor() != gs->grabber_cursor)
-        SDL_SetCursor(gs->grabber_cursor);
+        /* SDL_SetCursor(gs->grabber_cursor); */
 
     if (input->mouse_pressed[SDL_BUTTON_RIGHT]) {
         chisel_blocker->side = (chisel_blocker->side == 1) ? 2 : 1;
@@ -200,10 +200,10 @@ void chisel_blocker_draw() {
     }
 
     SDL_Texture *prev_target = SDL_GetRenderTarget(gs->renderer);
-    SDL_SetTextureBlendMode(RenderTarget(gs, TARGET_CHISEL_BLOCKER), SDL_BLENDMODE_BLEND);
+    SDL_SetTextureBlendMode(RenderTarget(gs, RENDER_TARGET_CHISEL_BLOCKER), SDL_BLENDMODE_BLEND);
     
-    Assert(gs->window, RenderTarget(gs, TARGET_CHISEL_BLOCKER));
-    SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, TARGET_CHISEL_BLOCKER));
+    Assert(gs->window, RenderTarget(gs, RENDER_TARGET_CHISEL_BLOCKER));
+    SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, RENDER_TARGET_CHISEL_BLOCKER));
 
     SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 0);
     SDL_RenderClear(gs->renderer);
@@ -318,13 +318,13 @@ void chisel_blocker_draw() {
         }
     }
 
-    SDL_SetTextureBlendMode(RenderTarget(gs, TARGET_CHISEL_BLOCKER), SDL_BLENDMODE_BLEND);
+    SDL_SetTextureBlendMode(RenderTarget(gs, RENDER_TARGET_CHISEL_BLOCKER), SDL_BLENDMODE_BLEND);
     if (gs->chisel_blocker_mode)
-        SDL_SetTextureAlphaMod(RenderTarget(gs, TARGET_CHISEL_BLOCKER), 255);
+        SDL_SetTextureAlphaMod(RenderTarget(gs, RENDER_TARGET_CHISEL_BLOCKER), 255);
     else
-        SDL_SetTextureAlphaMod(RenderTarget(gs, TARGET_CHISEL_BLOCKER), 128);
+        SDL_SetTextureAlphaMod(RenderTarget(gs, RENDER_TARGET_CHISEL_BLOCKER), 128);
 
-    SDL_RenderCopy(gs->renderer, RenderTarget(gs, TARGET_CHISEL_BLOCKER), NULL, NULL);
+    SDL_RenderCopy(gs->renderer, RenderTarget(gs, RENDER_TARGET_CHISEL_BLOCKER), NULL, NULL);
     
     for (int i = 0; i < gs->gw*gs->gh; i++) {
         SDL_SetRenderDrawColor(gs->renderer, 255, 255, 255, 16);
diff --git a/src/converter.c b/src/converter.c
index 744c79e..a23c2fb 100644
--- a/src/converter.c
+++ b/src/converter.c
@@ -21,11 +21,7 @@ internal bool can_place_item_in_slot(int type, int slot) {
     bool can_put_fuel = false;
     
     if (slot == SLOT_FUEL) {
-        switch (type) {
-        case CELL_UNREFINED_COAL: case CELL_REFINED_COAL:
-            can_put_fuel = true;
-            break;
-        }
+        can_put_fuel = is_cell_fuel(type);
     }
     
     return
@@ -543,9 +539,90 @@ void converter_set_state(struct Converter *converter, enum Converter_State state
     }
 }
 
-static int fuel_converter_convert(struct Item *input1, struct Item *input2) {
+internal struct Converter_Checker converter_checker(struct Item *input1, struct Item *input2) {
+    Assert(gs->window, input1);
+    Assert(gs->window, input2);
+
+    return (struct Converter_Checker) {
+        input1, input2, 0
+    };
+}
+
+internal bool is_either_input_type(struct Converter_Checker *checker, int type, bool restart) {
+    Assert(gs->window, checker->input1);
+    Assert(gs->window, checker->input2);
+
+    if (restart) {
+        checker->current = 0;
+    }
+
+    if (checker->current == 0) {
+        if (checker->input1->type == type) {
+            checker->current = 2;
+        } else if (checker->input2->type == type) {
+            checker->current = 1;
+        } else {
+            return false;
+        }
+    } else {
+        if ((checker->current == 2 && checker->input2->type != type) ||
+            (checker->current == 1 && checker->input1->type != type)) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+internal bool is_either_input_tier(struct Converter_Checker *checker, int tier, bool is_fuel, bool restart) {
+    Assert(gs->window, checker->input1);
+    Assert(gs->window, checker->input2);
+
+    if (restart) {
+        checker->current = 0;
+    }
+
+    if (checker->current == 0) {
+        if (get_cell_tier(checker->input1->type) == tier) {
+            checker->current = 2;
+        } else if (get_cell_tier(checker->input2->type) == tier) {
+            checker->current = 1;
+        }
+    } else {
+        if (is_fuel) {
+            if ((checker->current == 2 && is_cell_fuel(checker->input2->type) && tier == get_cell_tier(checker->input2->type)) ||
+                (checker->current == 1 && is_cell_fuel(checker->input1->type) && tier == get_cell_tier(checker->input1->type)))
+            {
+                return true;
+            } else {
+                return false;
+            }
+        } else {
+            if ((checker->current == 2 && !is_cell_fuel(checker->input2->type) && tier == get_cell_tier(checker->input2->type)) ||
+                (checker->current == 1 && !is_cell_fuel(checker->input1->type) && tier == get_cell_tier(checker->input1->type)))
+            {
+                return true;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    return true;
+}
+
+//
+// TODO: We're trying to add working converters to the game with
+//       a little system to check if either input slots have the
+//       desired items. Right now, it doesn't really work properly,
+//       and has a bug on line 657 where the checker->current
+//       remains zero even after the first function call?
+//
+
+internal int fuel_converter_convert(struct Item *input1, struct Item *input2) {
     int result_type = 0;
     int number_inputs = (input1->type != 0) + (input2->type != 0);
+    int number_unique_inputs = 0;
 
     struct Item *input = NULL;
 
@@ -555,19 +632,40 @@ static int fuel_converter_convert(struct Item *input1, struct Item *input2) {
         input = input1;
     }
 
-    switch (input->type) {
-    case CELL_COBBLESTONE: case CELL_MARBLE: case CELL_DIRT: case CELL_SAND: case CELL_WOOD_PLANK:
-        result_type = CELL_WOOD_LOG;
-        break;
-    case CELL_GLASS: case CELL_WOOD_LOG: case CELL_QUARTZ:
-        result_type = CELL_UNREFINED_COAL;
-        break;
+    number_unique_inputs = get_number_unique_inputs(input1, input2);
+
+    if (number_unique_inputs == 1) {
+        if (input->type == CELL_DIRT ||
+            input->type == CELL_SAND ||
+            !is_cell_fuel(input->type) && get_cell_tier(input->type) == 1)
+        {
+            result_type = CELL_UNREFINED_COAL;
+        }
+    }
+    else if (number_unique_inputs == 2) {
+        struct Converter_Checker checker = converter_checker(input1, input2);
+
+        if (is_either_input_type(&checker, CELL_UNREFINED_COAL, false) &&
+            is_either_input_tier(&checker, 2, false, false))
+        {
+            result_type = CELL_REFINED_COAL;
+        }
+
+        else if (is_either_input_type(&checker, CELL_UNREFINED_COAL, true) &&
+                 is_either_input_type(&checker, CELL_LAVA, false))
+        {
+            result_type = CELL_ICE;
+        }
     }
 
     return result_type;
 }
 
-static int material_converter_convert(struct Item *input1, struct Item *input2) {
+internal int material_converter_convert(struct Item *input1, struct Item *input2, struct Item *fuel) {
+    Assert(gs->window, input1);
+    Assert(gs->window, input2);
+    Assert(gs->window, fuel);
+
     int result_type = 0;
     int number_inputs = (input1->type != 0) + (input2->type != 0);
 
@@ -578,19 +676,35 @@ static int material_converter_convert(struct Item *input1, struct Item *input2)
     } else if (number_inputs == 2) {
         input = input1;
     }
-
-    switch (input->type) {
-    case CELL_SAND:
-        result_type = CELL_GLASS;
+    
+    switch (fuel->type) {
+    case CELL_UNREFINED_COAL:
+        switch (input->type) {
+        case CELL_SAND:
+            result_type = CELL_GLASS;
+            break;
+        }
+        break;
+    case CELL_REFINED_COAL:
+        switch (input->type) {
+        case CELL_SAND:
+            result_type = CELL_GRANITE;
+            break;
+        }
+        break;
+    case CELL_LAVA:
+        switch (input->type) {
+        case CELL_SAND:
+            result_type = CELL_SANDSTONE;
+            break;
+        }
         break;
     }
-
+    
     return result_type;
 }
 
-// Calculate the ratio of inputs -> output.
-static float calculate_output_ratio(struct Item *input1, struct Item *input2) {
-    float result = 0.f;
+internal int get_number_unique_inputs(struct Item *input1, struct Item *input2) {
     int number_inputs = (input1->type != 0) + (input2->type != 0);
     int number_unique_inputs = 0;
 
@@ -604,6 +718,14 @@ static float calculate_output_ratio(struct Item *input1, struct Item *input2) {
         }
     }
 
+    return number_unique_inputs;
+}
+
+// Calculate the ratio of inputs -> output.
+internal float calculate_output_ratio(struct Item *input1, struct Item *input2) {
+    float result = 0.f;
+    int number_unique_inputs = get_number_unique_inputs(input1, input2);
+
     result = number_unique_inputs * number_unique_inputs;
 
     return result;
@@ -622,19 +744,23 @@ bool converter_convert(struct Converter *converter) {
 
     if (converter->type == CONVERTER_MATERIAL) {
         fuel = &converter->slots[SLOT_FUEL].item;
+        if (!fuel)
+        {
+            return false;
+        }
     }
 
     int number_inputs = (input1->type != 0) + (input2->type != 0);
 
     if (!number_inputs) return false;
-    if (fuel && !fuel->type && fuel->amount == 0) return false;
+    if (fuel && (!fuel->type || fuel->amount == 0)) return false;
 
     struct Item *input = NULL;
 
     if (converter->type == CONVERTER_FUEL) {
         temp_output_type = fuel_converter_convert(input1, input2);
     } else if (converter->type == CONVERTER_MATERIAL) {
-        temp_output_type = material_converter_convert(input1, input2);
+        temp_output_type = material_converter_convert(input1, input2, fuel);
     }
 
     if (!temp_output_type) return false;
@@ -690,3 +816,37 @@ bool converter_convert(struct Converter *converter) {
 
     return !final_conversion || !did_convert;
 }
+
+// Possibilities:
+//   Tiers 1, 2, or 3.
+//   Returns 0 if no tier is specified.
+int get_cell_tier(int type) {
+    switch (type) {
+    case CELL_MARBLE: case CELL_COBBLESTONE: case CELL_SANDSTONE:
+        return 1;
+        break;
+    case CELL_CEMENT: case CELL_CONCRETE: case CELL_QUARTZ: case CELL_GLASS:
+        return 2;
+        break;
+    case CELL_GRANITE: case CELL_BASALT: case CELL_DIAMOND: // case CELL_GOLD:
+        return 3;
+        break;
+
+    case CELL_UNREFINED_COAL:
+        return 1;
+    case CELL_REFINED_COAL:
+        return 2;
+    case CELL_LAVA:
+        return 3;
+    }
+
+    return 0; // 0 = not specified in any tier.
+}
+
+bool is_cell_fuel(int type) {
+    switch (type) {
+    case CELL_REFINED_COAL: case CELL_UNREFINED_COAL: case CELL_LAVA:
+        return true;
+    }
+    return false;
+}
diff --git a/src/converter.h b/src/converter.h
index 78dbd3e..48fe4fa 100644
--- a/src/converter.h
+++ b/src/converter.h
@@ -7,7 +7,7 @@
 #define CONVERTER_NAME_LEN 32
 
 struct Item {
-    int type;
+    enum Cell_Type type;
     int amount;
 };
 
@@ -68,6 +68,11 @@ struct Converter {
     struct Arrow arrow;
 };
 
+struct Converter_Checker {
+    struct Item *input1, *input2;
+    int current; // 1 or 2 [0 when first initialized]
+};
+
 void item_draw(struct Item *item, int x, int y, int w, int h);
 void item_tick(struct Item *item, struct Slot *slot, int x, int y, int w, int h);
 
@@ -92,4 +97,7 @@ void slot_draw(struct Slot *slot);
 
 struct Placer *converter_get_current_placer();
 
+int get_cell_tier(int type);
+bool is_cell_fuel(int type);
+
 #endif  /* CONVERTER_H */
diff --git a/src/cursor.c b/src/cursor.c
index 225a653..b45ca86 100644
--- a/src/cursor.c
+++ b/src/cursor.c
@@ -125,5 +125,5 @@ SDL_Cursor *init_system_cursor(const char **image) {
 
 void _set_cursor(SDL_Cursor *cursor, const char *file, int line) {
     /* printf("Set to %p at file %s and line %d.\n", (void*)cursor, file, line); fflush(stdout); */
-    SDL_SetCursor(cursor);
+    /* SDL_SetCursor(cursor); */
 }
diff --git a/src/game.c b/src/game.c
index c11d7c5..f0b5188 100644
--- a/src/game.c
+++ b/src/game.c
@@ -83,7 +83,7 @@ bool game_tick_event(struct Game_State *state, SDL_Event *event) {
             break;
         case SDLK_g:
             if (input->keys[SDL_SCANCODE_LCTRL]) {
-                set_text_field("Goto Level", "", goto_level_string_hook);
+	            set_text_field("Goto Level", "", goto_level_string_hook);
             }
             break;
         case SDLK_o:
@@ -126,12 +126,13 @@ bool game_tick_event(struct Game_State *state, SDL_Event *event) {
 
             Assert(gs->window, obj != -1);
 
-            printf("Cell %d, %d: Pos: (%f, %f), Type: %s, Rand: %d, Object: %d, Time: %d, Vx: %f, Vy: %f, Blob: %u\n",
+            printf("Cell %d, %d: Pos: (%f, %f), Type: %s, ID: %d, Rand: %d, Object: %d, Time: %d, Vx: %f, Vy: %f, Blob: %u\n",
                    input->mx,
                    input->my,
                    c->vx_acc,
                    c->vy_acc,
                    name,
+                   c->id,
                    c->rand,
                    c->object,
                    c->time,
@@ -210,7 +211,6 @@ bool game_tick_event(struct Game_State *state, SDL_Event *event) {
     return is_running;
 }
 
-// Returns false if we want to exit.
 void game_run(struct Game_State *state) {
     gs = state;
 
diff --git a/src/game.h b/src/game.h
index 9b9d45a..a2f7d41 100644
--- a/src/game.h
+++ b/src/game.h
@@ -12,8 +12,6 @@
 
 #include "shared.h"
 
-// Put all this shit into the platform/sdl layer.
-
 __declspec(dllexport) void game_init(struct Game_State *state, int level);
 __declspec(dllexport) bool game_tick_event(struct Game_State *state, SDL_Event *event);
 __declspec(dllexport) void game_run(struct Game_State *state);
diff --git a/src/grabber.c b/src/grabber.c
index 8c3b6e9..ebed064 100644
--- a/src/grabber.c
+++ b/src/grabber.c
@@ -24,18 +24,7 @@ void grabber_tick() {
     if (grabber->object_holding != -1) {
         int dx = (int)grabber->x-px;
         int dy = (int)grabber->y-py;
-        /* float len = sqrt(dx*dx + dy*dy); */
-        /* float ux = dx/len; */
-        /* float uy = dy/len; */
-
-        /* float vx = 0, vy = 0; */
-
-        /* int i = 0; */
-        /* while (sqrt(vx*vx + vy*vy) < len) { */
         object_attempt_move(grabber->object_holding, dx, dy);
-        /*     vx += ux; */
-        /*     vy += uy; */
-        /* } */
     }
 
     if (gs->input.mouse & SDL_BUTTON(SDL_BUTTON_LEFT)) {
diff --git a/src/grid.c b/src/grid.c
index e7ffcca..4a15199 100644
--- a/src/grid.c
+++ b/src/grid.c
@@ -58,11 +58,6 @@ void grid_init(int w, int h) {
         gs->grid_layers[i] = push_memory(gs->persistent_memory, w*h, sizeof(struct Cell));
     }
 
-    gs->grid = gs->grid_layers[0];
-    gs->fg_grid = gs->grid_layers[1];
-    gs->gas_grid = gs->grid_layers[2];
-    gs->pickup_grid = gs->grid_layers[3];
-
     memset(gs->objects, 0, sizeof(struct Object)*MAX_OBJECTS);
     for (int i = 0; i < MAX_OBJECTS; i++) {
         for (int j = 0; j < 3; j++) {
@@ -77,8 +72,18 @@ void grid_init(int w, int h) {
         for (int j = 0; j < NUM_GRID_LAYERS; j++) {
             gs->grid_layers[j][i] = (struct Cell){.type = 0, .object = -1, .depth = 255 };
             gs->grid_layers[j][i].rand = rand();
+            gs->grid_layers[j][i].id = i;
         }
     }
+
+    // TODO: Make sure the grid IDs work properly
+    //       so the grabber can latch onto a cell
+    //       from frame to frame.
+
+    gs->grid = gs->grid_layers[0];
+    gs->fg_grid = gs->grid_layers[1];
+    gs->gas_grid = gs->grid_layers[2];
+    gs->pickup_grid = gs->grid_layers[3];
 }
 
 SDL_Color pixel_from_index(struct Cell *cells, int i) {
@@ -610,10 +615,19 @@ void grid_array_draw(struct Cell *array) {
                 col.g *= fac;
                 col.b *= fac;
             }
-            
+
             if (DRAW_PRESSURE && gs->objects[gs->object_count-1].blob_data[gs->chisel->size].blobs[x+y*gs->gw]) {
-                Uint8 c = (Uint8)(255 * ((float)gs->objects[gs->object_count-1].blob_data[gs->chisel->size].blob_pressures[gs->objects[gs->object_count-1].blob_data[gs->chisel->size].blobs[x+y*gs->gw]] / MAX_PRESSURE)); // ??? Holy fuck.
-                SDL_SetRenderDrawColor(gs->renderer, c, c, c, 255);
+                // Uint8 c = (Uint8)(255 * ((float)gs->objects[gs->object_count-1].blob_data[gs->chisel->size].blob_pressures[gs->objects[gs->object_count-1].blob_data[gs->chisel->size].blobs[x+y*gs->gw]] / MAX_PRESSURE)); // ??? Holy fuck.
+
+                int blob_pressure = (float)gs->objects[gs->object_count-1].blob_data[gs->chisel->size].blob_pressures[gs->objects[gs->object_count-1].blob_data[gs->chisel->size].blobs[x+y*gs->gw]];
+                float normalized_pressure = (float)blob_pressure / MAX_PRESSURE;
+
+                if (normalized_pressure >= get_pressure_threshold(gs->chisel->size)) {
+                    SDL_SetRenderDrawColor(gs->renderer, 255, 0, 0, 255);
+                } else {
+                    SDL_SetRenderDrawColor(gs->renderer, 255, 255, 255, 255);
+                }
+
             } else {
                 SDL_SetRenderDrawColor(gs->renderer, col.r, col.g, col.b, col.a);
             }
diff --git a/src/grid.h b/src/grid.h
index 4b2efbc..69c4bd2 100644
--- a/src/grid.h
+++ b/src/grid.h
@@ -65,30 +65,6 @@ enum Cell_Type {
     CELL_TYPE_COUNT
 };
 
-/* enum Cell_Type { */
-/*     CELL_NONE, */
-/*     CELL_MARBLE, */
-/*     CELL_COBBLESTONE, */
-/*     CELL_QUARTZ, */
-/*     CELL_GRANITE, */
-/*     CELL_BASALT, */
-/*     CELL_WOOD_LOG, */
-/*     CELL_WOOD_PLANK, */
-/*     CELL_DIRT, */
-/*     CELL_SAND, */
-/*     CELL_GLASS, */
-/*     CELL_WATER, */
-/*     CELL_COAL, */
-/*     CELL_STEAM, */
-/*     CELL_DIAMOND, */
-/*     CELL_ICE, */
-/*     CELL_LEAF, */
-/*     CELL_SMOKE, */
-/*     CELL_DUST, */
-/*     CELL_LAVA, */
-/*     CELL_TYPE_COUNT */
-/* }; */
-
 struct Cell {
     enum Cell_Type type;  // The type of this cell.
     int id;               // Unique ID for each cell.
diff --git a/src/gui.c b/src/gui.c
index d992dd8..6f2e840 100644
--- a/src/gui.c
+++ b/src/gui.c
@@ -46,7 +46,7 @@ void gui_init() {
 /*         button_deallocate(gui->tool_buttons[i]); */
 /*     } */
 /*     SDL_DestroyTexture(gui->popup_texture); */
-/*     SDL_DestroyTexture(RenderTarget(gs, TARGET_GUI_TOOLBAR)); */
+/*     SDL_DestroyTexture(RenderTarget(gs, RENDER_TARGET_GUI_TOOLBAR)); */
 /* } */
 
 void gui_tick() {
@@ -69,7 +69,7 @@ void gui_tick() {
 
     if (gui->popup) {
         if (SDL_GetCursor() != gs->grabber_cursor) {
-            SDL_SetCursor(gs->grabber_cursor);
+            /* SDL_SetCursor(gs->grabber_cursor); */
             /* SDL_ShowCursor(1); */
         }
 
@@ -118,10 +118,10 @@ void gui_draw() {
     // Draw the toolbar buttons.
     SDL_Texture *old = SDL_GetRenderTarget(gs->renderer);
 
-    SDL_SetTextureBlendMode(RenderTarget(gs, TARGET_GUI_TOOLBAR), SDL_BLENDMODE_BLEND);
+    SDL_SetTextureBlendMode(RenderTarget(gs, RENDER_TARGET_GUI_TOOLBAR), SDL_BLENDMODE_BLEND);
 
-    Assert(gs->window, RenderTarget(gs, TARGET_GUI_TOOLBAR));
-    SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, TARGET_GUI_TOOLBAR));
+    Assert(gs->window, RenderTarget(gs, RENDER_TARGET_GUI_TOOLBAR));
+    SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, RENDER_TARGET_GUI_TOOLBAR));
 
     SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 0);
     SDL_RenderClear(gs->renderer);
@@ -140,7 +140,7 @@ void gui_draw() {
     };
 
     SDL_SetRenderTarget(gs->renderer, NULL);
-    SDL_RenderCopy(gs->renderer, RenderTarget(gs, TARGET_GUI_TOOLBAR), NULL, &dst);
+    SDL_RenderCopy(gs->renderer, RenderTarget(gs, RENDER_TARGET_GUI_TOOLBAR), NULL, &dst);
     SDL_SetRenderTarget(gs->renderer, old);
 }
 
diff --git a/src/knife.c b/src/knife.c
index 246643d..b6423ea 100644
--- a/src/knife.c
+++ b/src/knife.c
@@ -76,10 +76,10 @@ void knife_update_texture() {
     struct Knife *knife = &gs->knife;
 
     SDL_Texture *prev_target = SDL_GetRenderTarget(gs->renderer);
-    SDL_SetTextureBlendMode(RenderTarget(gs, TARGET_KNIFE), SDL_BLENDMODE_BLEND);
+    SDL_SetTextureBlendMode(RenderTarget(gs, RENDER_TARGET_KNIFE), SDL_BLENDMODE_BLEND);
     
-    Assert(gs->window, RenderTarget(gs, TARGET_KNIFE));
-    SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, TARGET_KNIFE));
+    Assert(gs->window, RenderTarget(gs, RENDER_TARGET_KNIFE));
+    SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, RENDER_TARGET_KNIFE));
 
     SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 0);
     SDL_RenderClear(gs->renderer);
@@ -103,5 +103,5 @@ void knife_draw() {
     struct Knife *knife = &gs->knife;
 
     knife_update_texture();
-    SDL_RenderCopy(gs->renderer, RenderTarget(gs, TARGET_KNIFE), NULL, NULL);
+    SDL_RenderCopy(gs->renderer, RenderTarget(gs, RENDER_TARGET_KNIFE), NULL, NULL);
 }
diff --git a/src/level.c b/src/level.c
index 5f1a450..2b1daff 100644
--- a/src/level.c
+++ b/src/level.c
@@ -202,16 +202,16 @@ void level_tick() {
         if (input->my < 0) { // If the mouse is in the GUI gs->window...
             /* SDL_ShowCursor(1); */
             if (SDL_GetCursor() != gs->normal_cursor) {
-                SDL_SetCursor(gs->normal_cursor);
+                /* SDL_SetCursor(gs->normal_cursor); */
             }
             break;
         } else if (gs->current_tool == TOOL_GRABBER) {
             if (SDL_GetCursor() != gs->grabber_cursor) {
                 /* SDL_ShowCursor(1); */
-                SDL_SetCursor(gs->grabber_cursor);
+                /* SDL_SetCursor(gs->grabber_cursor); */
             }
         } else if (SDL_GetCursor() != gs->normal_cursor) {
-            SDL_SetCursor(gs->normal_cursor);
+            /* SDL_SetCursor(gs->normal_cursor); */
         }
     
         chisel_blocker_tick();
@@ -254,8 +254,8 @@ void level_draw() {
         level_draw_intro();
         break;
     case LEVEL_STATE_OUTRO: case LEVEL_STATE_PLAY:
-        Assert(gs->window, RenderTarget(gs, TARGET_GLOBAL));
-        SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, TARGET_GLOBAL));
+        Assert(gs->window, RenderTarget(gs, RENDER_TARGET_GLOBAL));
+        SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, RENDER_TARGET_GLOBAL));
         
         SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 255);
         SDL_RenderClear(gs->renderer);
@@ -299,7 +299,7 @@ void level_draw() {
         };
 
         SDL_SetRenderTarget(gs->renderer, NULL);
-        SDL_RenderCopy(gs->renderer, RenderTarget(gs, TARGET_GLOBAL), NULL, &dst);
+        SDL_RenderCopy(gs->renderer, RenderTarget(gs, RENDER_TARGET_GLOBAL), NULL, &dst);
 
         gui_popup_draw();
         
@@ -395,8 +395,8 @@ void level_draw() {
 void level_draw_intro() {
     struct Level *level = &gs->levels[gs->level_current];
 
-    Assert(gs->window, RenderTarget(gs, TARGET_GLOBAL));
-    SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, TARGET_GLOBAL));
+    Assert(gs->window, RenderTarget(gs, RENDER_TARGET_GLOBAL));
+    SDL_SetRenderTarget(gs->renderer, RenderTarget(gs, RENDER_TARGET_GLOBAL));
         
     SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 255);
     SDL_RenderClear(gs->renderer);
@@ -411,7 +411,7 @@ void level_draw_intro() {
     }
 
     SDL_SetRenderTarget(gs->renderer, NULL);
-    SDL_RenderCopy(gs->renderer, RenderTarget(gs, TARGET_GLOBAL), NULL, NULL);
+    SDL_RenderCopy(gs->renderer, RenderTarget(gs, RENDER_TARGET_GLOBAL), NULL, NULL);
 
     char name[256] = {0};
     sprintf(name, "Level %d: %s", level->index+1, level->name);
diff --git a/src/main.c b/src/main.c
index d861496..3fb6333 100644
--- a/src/main.c
+++ b/src/main.c
@@ -5,7 +5,7 @@
 // calls functions to run the game etc.
 //
 // The app itself is, as I said, compiled to a .dll and can
-// be found in ../game.c
+// be found in game.c
 //
 // The benefit of doing this is you get live code reloading;
 // you can compile your code while the app is running and
@@ -19,7 +19,7 @@
 // the same heap. The solution is to simply allocate a huge
 // block of memory at the start of the program in this file
 // using VirtualAlloc() and give it pointers into that
-// memory block through functions defined in ../shared.h
+// memory block through functions defined in shared.h
 //
 // This method also means you can't store "local persistant"
 // (static) variables inside functions nor global variables
diff --git a/src/placer.c b/src/placer.c
index 8831c94..3f1852f 100644
--- a/src/placer.c
+++ b/src/placer.c
@@ -24,8 +24,8 @@ void placer_init(int num) {
     
     placer->object_index = -1;
     placer->did_click = 0;
-    placer->contains_type = CELL_DIRT;
-    placer->contains_amount = 5000;
+    placer->contains_type = 0;
+    placer->contains_amount = 0;
     placer->radius = 2;
 
     placer->placing_solid_time = 0;
@@ -33,8 +33,11 @@ void placer_init(int num) {
     placer->rect.x = placer->rect.y = -1;
 
     if (num == 1) {
-        placer->contains_type = 0;
-        placer->contains_amount = 0;
+        placer->contains_type = CELL_UNREFINED_COAL;
+        placer->contains_amount = 200;
+    } else if (num == 0) {
+        placer->contains_type = CELL_LAVA;
+        placer->contains_amount = 200;
     }
 }
 
@@ -365,10 +368,10 @@ void placer_draw(struct Placer *placer, bool full_size) {
 
     if (gs->gui.popup) {
         if (SDL_GetCursor() != gs->placer_cursor) {
-            SDL_SetCursor(gs->placer_cursor);
+            /* SDL_SetCursor(gs->placer_cursor); */
         }
     } else if (SDL_GetCursor() == gs->placer_cursor) {
-        SDL_SetCursor(gs->normal_cursor);
+        /* SDL_SetCursor(gs->normal_cursor); */
     }
     
     if (placer->state == PLACER_SUCK_MODE || placer->state == PLACER_PLACE_CIRCLE_MODE) {
diff --git a/src/shared.h b/src/shared.h
index aeb5735..63a1ae8 100644
--- a/src/shared.h
+++ b/src/shared.h
@@ -59,7 +59,7 @@
 //
 
 struct Memory {
-    char name[64]; // The name of this memory buffer. For debugging purposes.
+    char name[64]; // The name of this memory buffer for debugging purposes.
 
     Uint8 *data;
     Uint8 *cursor;
diff --git a/todo.txt b/todo.txt
index cac56d1..69fdd11 100644
--- a/todo.txt
+++ b/todo.txt
@@ -1,7 +1,5 @@
       --------------------------TODO----------------------------
 
-x Add the new types into the game and set everything up structurally.
-
  - There are two converters- the fuel converter and the material
    converter. Upon chiseling, dust is generated and put onto a second
    layer, which is able to be picked up by the placer. Materials
@@ -26,9 +24,6 @@ x Add the new types into the game and set everything up structurally.
   clicking, store the position of a cell in the object then track
   that cell upon grabbing the object.
 
-x Implement transient memory instead of grid_temp and replace
-  transient_alloc with another memory arena.
-
 - Remove all warnings at /W4
 
      ---------------------------Ideas----------------------------
