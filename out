diff --git a/bin/.vs/win32_sculpture/v17/.suo b/bin/.vs/win32_sculpture/v17/.suo
index 01f57b1..0d9010d 100644
Binary files a/bin/.vs/win32_sculpture/v17/.suo and b/bin/.vs/win32_sculpture/v17/.suo differ
diff --git a/bin/.vs/win32_sculpture/v17/Browse.VC.db b/bin/.vs/win32_sculpture/v17/Browse.VC.db
index b60c7de..2c5733c 100644
Binary files a/bin/.vs/win32_sculpture/v17/Browse.VC.db and b/bin/.vs/win32_sculpture/v17/Browse.VC.db differ
diff --git a/bin/obj/game.obj b/bin/obj/game.obj
index 71b7498..e018ffc 100644
Binary files a/bin/obj/game.obj and b/bin/obj/game.obj differ
diff --git a/bin/obj/main.obj b/bin/obj/main.obj
index b0c7fd3..70126ba 100644
Binary files a/bin/obj/main.obj and b/bin/obj/main.obj differ
diff --git a/bin/sculpture.dll b/bin/sculpture.dll
index 34bafe2..526987f 100644
Binary files a/bin/sculpture.dll and b/bin/sculpture.dll differ
diff --git a/bin/sculpture_temp.dll b/bin/sculpture_temp.dll
index 34bafe2..526987f 100644
Binary files a/bin/sculpture_temp.dll and b/bin/sculpture_temp.dll differ
diff --git a/bin/vc140.pdb b/bin/vc140.pdb
index 681a85a..93dc9f1 100644
Binary files a/bin/vc140.pdb and b/bin/vc140.pdb differ
diff --git a/bin/win32_sculpture.exe b/bin/win32_sculpture.exe
index a642272..f21f7d7 100644
Binary files a/bin/win32_sculpture.exe and b/bin/win32_sculpture.exe differ
diff --git a/bin/win32_sculpture.pdb b/bin/win32_sculpture.pdb
index b730cd6..5e7f79f 100644
Binary files a/bin/win32_sculpture.pdb and b/bin/win32_sculpture.pdb differ
diff --git a/build.bat b/build.bat
index 1cb4d24..8ab7b62 100644
--- a/build.bat
+++ b/build.bat
@@ -1,6 +1,6 @@
 @echo off
 
-set Compiler_Flags=/nologo /diagnostics:caret /W4 /WX /wd4189 /wd4389 /wd4244 /wd4127 /wd4245 /Zi /GR- /EHa- /Odi /MTd /FC /Fo:"obj\\" /D_CRT_SECURE_NO_WARNINGS
+set Compiler_Flags=/nologo /diagnostics:caret /W4 /WX /wd4389 /wd4244 /Zi /GR- /EHa- /Odi /MTd /FC /Fo:"obj\\" /D_CRT_SECURE_NO_WARNINGS
 set Linker_Flags=user32.lib SDL2.lib SDL2_ttf.lib SDL2_image.lib
 
 rem gcc main.c *.c -Wall -pedantic -lSDL2 -lSDL2main -lSDL2_image -lSDL2_ttf -lSDL2_gfx -g -o ..\bin\win32_sculpture.exe
diff --git a/src/all.h b/src/all.h
index 4a1c6ba..094b680 100644
--- a/src/all.h
+++ b/src/all.h
@@ -12,11 +12,9 @@
 
 #include "typedefs.h"
 #include "cursor.h"
-#include "blob_hammer.h"
 #include "overlay.h"
 #include "grid.h"
 #include "chisel.h"
-#include "knife.h"
 #include "deleter.h"
 #include "popup.h"
 #include "placer.h"
diff --git a/src/assets.c b/src/assets.c
index defa431..db57c99 100644
--- a/src/assets.c
+++ b/src/assets.c
@@ -1,5 +1,3 @@
-#define CreateRenderTarget(width, height) (SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, width, height))
-
 //
 // In this file, we load / unload every single asset from file,
 // as well as every single global texture or surface created
@@ -11,6 +9,8 @@
 // This is included only in the platform/SDL layer.
 //
 
+#define CreateRenderTarget(width, height) (SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, width, height))
+
 SDL_Texture *load_texture(SDL_Renderer *renderer, const char *fp) {
     SDL_Surface *surf = IMG_Load(fp);
     Assert(surf);
@@ -19,68 +19,6 @@ SDL_Texture *load_texture(SDL_Renderer *renderer, const char *fp) {
     return texture;
 }
 
-void get_filename_from_type(int type, char *out) {
-    switch (type) {
-    case CELL_NONE:        strcpy(out, "nothing"); break;
-    case CELL_DIRT:        strcpy(out, RES_DIR "/items/dirt.png"); break;
-    case CELL_SAND:        strcpy(out, RES_DIR "/items/sand.png"); break;
-        
-    case CELL_WATER:       strcpy(out, RES_DIR "/items/water.png"); break;
-    case CELL_ICE:         strcpy(out, RES_DIR "/items/ice.png"); break;
-    case CELL_STEAM:       strcpy(out, RES_DIR "/items/steam.png"); break;
-    
-    case CELL_WOOD_LOG:    strcpy(out, RES_DIR "/items/wood_log.png"); break;
-    case CELL_WOOD_PLANK:  strcpy(out, RES_DIR "/items/wood_plank.png"); break;
-    
-    case CELL_COBBLESTONE: strcpy(out, RES_DIR "/items/cobblestone.png"); break;
-    case CELL_MARBLE:      strcpy(out, RES_DIR "/items/marble.png"); break;
-    case CELL_SANDSTONE:   strcpy(out, RES_DIR "/items/sandstone.png"); break;
-    
-    case CELL_CEMENT:      strcpy(out, RES_DIR "/items/cement.png"); break;
-    case CELL_CONCRETE:    strcpy(out, RES_DIR "/items/concrete.png"); break;
-    
-    case CELL_QUARTZ:      strcpy(out, RES_DIR "/items/quartz.png"); break;
-    case CELL_GLASS:       strcpy(out, RES_DIR "/items/glass.png"); break;
-    
-    case CELL_GRANITE:     strcpy(out, RES_DIR "/items/granite.png"); break;
-    case CELL_BASALT:      strcpy(out, RES_DIR "/items/basalt.png"); break;
-    case CELL_DIAMOND:     strcpy(out, RES_DIR "/items/diamond.png"); break;
-    
-    case CELL_UNREFINED_COAL: strcpy(out, RES_DIR "/items/coal.png"); break;
-    case CELL_REFINED_COAL:   strcpy(out, RES_DIR "/items/coal.png"); break;
-    case CELL_LAVA:           strcpy(out, RES_DIR "/items/lava.png"); break;
-    
-    case CELL_SMOKE:       strcpy(out, RES_DIR "/items/smoke.png"); break;
-    case CELL_DUST:        strcpy(out, RES_DIR "/items/dust.png"); break;
-    }
-}
-
-void get_file_from_tool(int type, char *out) {
-    switch (type) {
-    case TOOL_CHISEL_SMALL:  strcpy(out, "chisel_small.png"); break;
-    case TOOL_CHISEL_MEDIUM: strcpy(out, "chisel_medium.png"); break;
-    case TOOL_CHISEL_LARGE:  strcpy(out, "chisel_large.png"); break;
-    case TOOL_KNIFE:         strcpy(out, "knife.png"); break;
-    case TOOL_DELETER:       strcpy(out, "deleter.png"); break;
-    case TOOL_HAMMER:        strcpy(out, "hammer.png"); break;
-    case TOOL_PLACER:        strcpy(out, "placer.png"); break;
-    case TOOL_GRABBER:       strcpy(out, "pointer.png"); break;
-    }
-}
-
-void get_name_from_tool(int type, char *out) {
-    switch (type) {
-    case TOOL_CHISEL_SMALL:  strcpy(out, "Small Chisel"); break;
-    case TOOL_CHISEL_MEDIUM: strcpy(out, "Medium Chisel"); break;
-    case TOOL_CHISEL_LARGE:  strcpy(out, "Large Chisel"); break;
-    case TOOL_KNIFE:         strcpy(out, "Knife"); break;
-    case TOOL_DELETER:       strcpy(out, "Deleter"); break;
-    case TOOL_HAMMER:        strcpy(out, "Hammer"); break;
-    case TOOL_PLACER:        strcpy(out, "Placer"); break;
-    case TOOL_GRABBER:       strcpy(out, "Grabber"); break;
-    }
-}
-
 // Creates all render targets for all the levels.
 void render_targets_init(SDL_Renderer *renderer,
                          int width, // In screen coords, not game coords.
@@ -126,7 +64,7 @@ void textures_init(SDL_Renderer *renderer, struct Textures *textures) {
     textures->knife = load_texture(renderer, RES_DIR "/knife.png");
     textures->popup = load_texture(renderer, RES_DIR "/popup.png");
 
-    for (int i = 0; i < TOOL_COUNT; i++) {
+    for (enum Tool_Type i = 0; i < TOOL_COUNT; i++) {
         char filename[128] = {0};
         char path[128] = {0};
 
diff --git a/src/assets.h b/src/assets.h
index 69e2a20..b400191 100644
--- a/src/assets.h
+++ b/src/assets.h
@@ -4,8 +4,6 @@
 enum {
     RENDER_TARGET_GLOBAL, // The main render target
     RENDER_TARGET_GUI_TOOLBAR, // The render target showing the tool buttons
-    RENDER_TARGET_KNIFE,
-    RENDER_TARGET_BLOB_HAMMER,
     RENDER_TARGET_CHISEL_BLOCKER,
     RENDER_TARGET_CHISEL, // Use the same render target for each chisel.
     RENDER_TARGET_DELETER,
diff --git a/src/blob_hammer.c b/src/blob_hammer.c
deleted file mode 100644
index dcfcad5..0000000
--- a/src/blob_hammer.c
+++ /dev/null
@@ -1,175 +0,0 @@
-void blob_hammer_init() {
-    struct Blob_Hammer *blob_hammer = &gs->blob_hammer;
-    
-    blob_hammer->state = HAMMER_STATE_IDLE;
-    blob_hammer->timer = 0;
-    blob_hammer->swing_direction = 1;
-
-    blob_hammer->x = (f32)gs->gw/2;
-    blob_hammer->y = (f32)gs->gh/2;
-    blob_hammer->texture = gs->textures.blob_hammer;
-    SDL_QueryTexture(blob_hammer->texture, NULL, NULL, &blob_hammer->w, &blob_hammer->h);
-    blob_hammer->angle = 0;
-
-    if (blob_hammer->pixels == NULL) {
-        blob_hammer->pixels = arena_alloc(gs->persistent_memory, gs->gw*gs->gh, sizeof(Uint32));
-    }
-}
-
-void blob_hammer_update_texture() {
-    struct Blob_Hammer *blob_hammer = &gs->blob_hammer;
-    
-    SDL_Texture *prev_target = SDL_GetRenderTarget(gs->renderer);
-    SDL_SetTextureBlendMode(RenderTarget(RENDER_TARGET_BLOB_HAMMER), SDL_BLENDMODE_BLEND);
-    
-    Assert(RenderTarget(RENDER_TARGET_BLOB_HAMMER));
-    SDL_SetRenderTarget(gs->renderer, RenderTarget(RENDER_TARGET_BLOB_HAMMER));
-
-    SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 0);
-    SDL_RenderClear(gs->renderer);
-
-    // Actually render
-    SDL_Rect dst = {
-        (int)blob_hammer->x - blob_hammer->w/2,
-        (int)blob_hammer->y - blob_hammer->h,
-        blob_hammer->w, blob_hammer->h
-    };
-
-    SDL_Point center = { blob_hammer->w/2, blob_hammer->h };
-    SDL_RendererFlip flip = SDL_FLIP_NONE;
-
-    if (blob_hammer->swing_direction == -1) {
-        flip = SDL_FLIP_HORIZONTAL;
-    }
-
-    int angle = (int)blob_hammer->angle;
-    while (angle < 0)
-        angle += 360;
-
-    SDL_RenderCopyEx(gs->renderer, blob_hammer->texture, NULL, &dst, angle, &center, flip);
-
-    // Update pixels & reset render target.
-    SDL_RenderReadPixels(gs->renderer, NULL, 0, blob_hammer->pixels, 4*gs->gw);
-
-    SDL_SetRenderTarget(gs->renderer, prev_target);
-}
-
-void blob_hammer_tick() {
-    struct Blob_Hammer *blob_hammer = &gs->blob_hammer;
-    struct Input *input = &gs->input;
-    struct Chisel *chisel = gs->chisel;
-    
-    if (input->mouse_pressed[SDL_BUTTON_RIGHT]) {
-        blob_hammer->swing_direction = (blob_hammer->swing_direction == 1) ? -1 : 1;
-    }
-    
-    if (blob_hammer->state == HAMMER_STATE_IDLE && input->mouse_pressed[SDL_BUTTON_LEFT]) {
-        blob_hammer->state = HAMMER_STATE_WINDUP;
-        blob_hammer->timer = 10;
-        blob_hammer->prev_angle = blob_hammer->angle;
-    }
-
-    blob_hammer->is_changing_angle = input->keys[SDL_SCANCODE_LCTRL];
-
-    if (blob_hammer->is_changing_angle) {
-        f32 dx = input->mx - blob_hammer->x;
-        f32 dy = input->my - blob_hammer->y;
-        
-        f32 angle = atan2f(dy, dx);
-        angle /= 2 * (f32)M_PI;
-        angle *= 360;
-        angle += 270;
-        angle = angle / 22.5f;
-        angle = 22.5f * (int)angle;
-
-        int int_angle = (int)angle;
-        int_angle %= 360;
-
-        blob_hammer->angle = (f32)int_angle;
-    } else {
-        blob_hammer->x = (f32)input->mx;
-        blob_hammer->y = (f32)input->my;
-    }
-
-    switch (blob_hammer->state) {
-    case HAMMER_STATE_WINDUP:
-        if (blob_hammer->timer > 0) {
-            blob_hammer->timer--;
-        } else {
-            blob_hammer->state = HAMMER_STATE_SWING;
-            blob_hammer->timer = 3;
-            break;
-        }
-
-        const f32 speed = 5.0f;
-
-        blob_hammer->angle += blob_hammer->swing_direction * speed;
-        break;
-    case HAMMER_STATE_SWING:
-        if (blob_hammer->timer > 0) {
-            blob_hammer->timer--;
-        } else {
-            blob_hammer->state = HAMMER_STATE_AFTERSWING;
-            blob_hammer->timer = (int) minimum(4, (int)(blob_hammer->angle - blob_hammer->prev_angle));
-            break;
-        }
-
-        blob_hammer->angle -= blob_hammer->swing_direction * 25;
-
-        blob_hammer_update_texture();
-
-        for (int y = 0; y < gs->gh; y++) {
-            for (int x = 0; x < gs->gw; x++) {
-                if (blob_hammer->pixels[x+y*gs->gw] == 0) continue;
-                // Find the blob in this pixel,
-                // then check if it's already in the list.
-                // If not, add it.
-                    
-                Uint32 blob = gs->objects[0].blob_data[chisel->size].blobs[x+y*gs->gw];
-                if (blob == 0) continue;
-
-                int exists_in_array = 0;
-                for (int i = 0; i < blob_hammer->blobs_touched_count; i++) {
-                    if (blob_hammer->blobs_touched[i] == blob) {
-                        exists_in_array = 1;
-                        break;
-                    }
-                }
-
-                if (!exists_in_array && blob_hammer->blobs_touched_count < MAX_BLOBS_TOUCHED) {
-                    blob_hammer->blobs_touched[blob_hammer->blobs_touched_count++] = blob;
-                }
-            }
-        }
-        break;
-    case HAMMER_STATE_AFTERSWING:
-        if (blob_hammer->timer > 0) {
-            blob_hammer->timer--;
-        } else {
-            blob_hammer->state = HAMMER_STATE_IDLE;
-            blob_hammer->timer = 0;
-            blob_hammer->angle = blob_hammer->prev_angle;
-
-            for (int i = 0; i < blob_hammer->blobs_touched_count; i++) {
-                switch_blob_to_array(gs->grid,
-                                     gs->pickup_grid,
-                                     gs->object_current,
-                                     blob_hammer->blobs_touched[i],
-                                     chisel->size);
-                blob_hammer->blobs_touched[i] = 0;
-            }
-            blob_hammer->blobs_touched_count = 0;
-
-            save_state_to_next();
-            break;
-        }
-
-        blob_hammer->angle += blob_hammer->swing_direction;
-        break;
-    }
-}
-
-void blob_hammer_draw() {
-    blob_hammer_update_texture();
-    SDL_RenderCopy(gs->renderer, RenderTarget(RENDER_TARGET_BLOB_HAMMER), NULL, NULL);
-}
diff --git a/src/blob_hammer.h b/src/blob_hammer.h
deleted file mode 100644
index 08ef366..0000000
--- a/src/blob_hammer.h
+++ /dev/null
@@ -1,28 +0,0 @@
-#define MAX_BLOBS_TOUCHED 32
-
-// Used in chisel.c as well for the chisel's hammer state.
-enum Hammer_State {
-    HAMMER_STATE_IDLE,
-    HAMMER_STATE_WINDUP,
-    HAMMER_STATE_SWING,
-    HAMMER_STATE_AFTERSWING // Unused for chisel hammer
-};
-
-struct Blob_Hammer {
-    int state;
-    int timer;
-    
-    f32 x, y;
-    int w, h;
-
-    bool is_changing_angle;
-    int swing_direction;
-    f32 angle, prev_angle;
-
-    SDL_Texture *texture;
-
-    Uint32 *pixels;
-
-    Uint32 blobs_touched[MAX_BLOBS_TOUCHED];
-    int blobs_touched_count;
-};
diff --git a/src/blocker.c b/src/blocker.c
index 7f37b8c..36bda36 100644
--- a/src/blocker.c
+++ b/src/blocker.c
@@ -1,11 +1,3 @@
-bool is_angle_225(f64 deg_angle) {
-    f64 f = fabs(deg_angle);
-    if (f == 22.5 || f == 157.5 || f == 112.5 || f == 67.5) {
-        return true;
-    }
-    return false;
-}
-
 void blocker_add_point(int x, int y) {
     struct Blocker *blocker = &gs->blocker;
     blocker->points[blocker->point_count].x = x;
@@ -31,16 +23,16 @@ void blocker_tick() {
     struct Blocker *blocker = &gs->blocker;
     struct Input *input = &gs->input;
     
-    if (input->keys_pressed[SDL_SCANCODE_F6]) {
-        blocker->state = BLOCKER_STATE_OFF;
-    }
-    if (input->keys_pressed[SDL_SCANCODE_F7]) {
-        blocker->state = BLOCKER_STATE_LINE;
-    }
-    if (input->keys_pressed[SDL_SCANCODE_F8]) {
-        blocker->state = BLOCKER_STATE_CURVE;
-    }
-
+    // if (input->keys_pressed[SDL_SCANCODE_F6]) {
+    // blocker->state = BLOCKER_STATE_OFF;
+    // }
+    // if (input->keys_pressed[SDL_SCANCODE_F7]) {
+    // blocker->state = BLOCKER_STATE_LINE;
+    // }
+    // if (input->keys_pressed[SDL_SCANCODE_F8]) {
+    // blocker->state = BLOCKER_STATE_CURVE;
+    // }
+    
     if (blocker->state == BLOCKER_STATE_OFF) return;
     if (input->real_my < GUI_H) return;
 
diff --git a/src/chisel.h b/src/chisel.h
index 1f4b48f..95d88ba 100644
--- a/src/chisel.h
+++ b/src/chisel.h
@@ -3,6 +3,13 @@
 #define CHISEL_FORGIVING_AIM false // Do we check for surrounding cells?
 #define DRAW_CHISEL_HIGHLIGHTS true
 
+enum Hammer_State {
+    HAMMER_STATE_IDLE,
+    HAMMER_STATE_WINDUP,
+    HAMMER_STATE_SWING,
+    HAMMER_STATE_AFTERSWING // Unused for chisel hammer
+};
+
 struct Chisel_Hammer {
 	int state;
     f32 x, y;
diff --git a/src/game.c b/src/game.c
index 8b02b52..c713b02 100644
--- a/src/game.c
+++ b/src/game.c
@@ -6,7 +6,6 @@
 #include "overlay.c"
 #include "grid.c"
 #include "undo.c"
-#include "blob_hammer.c"
 #include "chisel_blocker.c"
 #include "spline.c"
 #include "blocker.c"
@@ -16,7 +15,6 @@
 #include "gui.c"
 #include "effects.c"
 #include "grabber.c"
-#include "knife.c"
 #include "deleter.c"
 #include "popup.c"
 #include "level.c"
@@ -69,6 +67,9 @@ export bool game_tick_event(struct Game_State *state, SDL_Event *event) {
         case SDLK_SPACE:
             gs->paused = !gs->paused;
             break;
+        case SDLK_SEMICOLON:
+            gui_message_stack_push("Test");
+            break;
         case SDLK_n:
             gs->step_one = 1;
             break;
@@ -165,22 +166,14 @@ export bool game_tick_event(struct Game_State *state, SDL_Event *event) {
             selected_tool = 1;
             break;
         case SDLK_4:
-            gs->current_tool = TOOL_KNIFE;
-            selected_tool = 1;
-            break;
-        case SDLK_5:
             gs->current_tool = TOOL_DELETER;
             selected_tool = 1;
             break;
-        case SDLK_6:
-            gs->current_tool = TOOL_HAMMER;
-            selected_tool = 1;
-            break;
-        case SDLK_7:
+        case SDLK_5:
             gs->current_tool = TOOL_PLACER;
             selected_tool = 1;
             break;
-        case SDLK_8:
+        case SDLK_6:
             gs->current_tool = TOOL_GRABBER;
             selected_tool = 1;
             break;
@@ -224,6 +217,9 @@ void draw_intro() {
     all_converters_draw();
 
     tooltip_draw(&gs->gui.tooltip);
+
+    gui_message_stack_tick_and_draw();
+
     text_field_draw();
 }
 
diff --git a/src/grid.c b/src/grid.c
index c0f026e..371e2cb 100644
--- a/src/grid.c
+++ b/src/grid.c
@@ -1,11 +1,3 @@
-bool is_in_bounds(int x, int y) {
-    return x >= 0 && y >= 0 && x < gs->gw && y < gs->gh;
-}
-
-bool is_in_boundsf(f32 x, f32 y) {
-    return is_in_bounds((int)x, (int)y);
-}
-
 int is_cell_hard(int type) {
     return
         type == CELL_ICE         ||
@@ -888,7 +880,9 @@ void grid_array_draw(struct Cell *array) {
                 col.b /= 2;
             }
 
-            if (DRAW_PRESSURE && gs->objects[gs->object_count-1].blob_data[gs->chisel->size].blobs[x+y*gs->gw]) {
+            const bool draw_pressure = true;
+
+            if (draw_pressure && gs->objects[gs->object_count-1].blob_data[gs->chisel->size].blobs[x+y*gs->gw]) {
                 int blob_pressure = (int)gs->objects[gs->object_count-1].blob_data[gs->chisel->size].blob_pressures[gs->objects[gs->object_count-1].blob_data[gs->chisel->size].blobs[x+y*gs->gw]];
                 f32 normalized_pressure = (f32) (blob_pressure / MAX_PRESSURE);
 
@@ -897,7 +891,6 @@ void grid_array_draw(struct Cell *array) {
                 } else {
                     SDL_SetRenderDrawColor(gs->renderer, 255, 255, 255, 255);
                 }
-
             } else {
                 SDL_SetRenderDrawColor(gs->renderer, col.r, col.g, col.b, col.a);
             }
diff --git a/src/grid.h b/src/grid.h
index b4a37dd..ac4797b 100644
--- a/src/grid.h
+++ b/src/grid.h
@@ -3,8 +3,6 @@
 #define MAX_OBJECTS 32
 #define NUM_GRID_LAYERS 4
 
-#define DRAW_PRESSURE false
-
 #define GRAV 0.5
 #define MAX_GRAV 4
 
@@ -12,9 +10,8 @@ enum Tool_Type {
     TOOL_CHISEL_SMALL,
     TOOL_CHISEL_MEDIUM,
     TOOL_CHISEL_LARGE,
-    TOOL_KNIFE,
+    TOOL_OVERLAY,
     TOOL_DELETER,
-    TOOL_HAMMER,
     TOOL_PLACER,
     TOOL_GRABBER,
     TOOL_COUNT
diff --git a/src/gui.c b/src/gui.c
index 23cf6e8..bc68941 100644
--- a/src/gui.c
+++ b/src/gui.c
@@ -1,1217 +1,1258 @@
-void converter_set_state(struct Converter *converter, enum Converter_State state) {
-    converter->state = state;
-    if (state == CONVERTER_OFF) {
-        converter->state = CONVERTER_OFF;
-        SDL_SetTextureColorMod(converter->arrow.texture, 255, 255, 255);
-    }
-}
-
-
-bool converter_is_layout_valid(struct Converter *converter) {
-    bool is_empty = true;
-    for (int i = 0; i < converter->slot_count; i++) {
-        if (converter->slots[i].item.type) {
-            is_empty = false;
-            break;
-        }
-    }
-    
-    if (is_empty) return false;
-    
-    return true;
-}
-
-void converter_begin_converting(void *converter_ptr) {
-    struct Converter *converter = (struct Converter *) converter_ptr;
-
-    if (!converter_is_layout_valid(converter))
-        return;
-
-    converter_set_state(converter, converter->state == CONVERTER_ON ? CONVERTER_OFF : CONVERTER_ON);
-}
-
-struct Placer *converter_get_current_placer() {
-    struct Placer *placers = gs->placers;
-    if (gs->current_placer == -1 || gs->current_tool != TOOL_PLACER) return NULL;
-    return &placers[gs->current_placer];
-}
-
-//////////////////////////////////////////
-
-struct Button *button_allocate(enum Button_Type type, SDL_Texture *texture, const char *tooltip_text, void (*on_pressed)(void*)) {
-    struct Button *b = arena_alloc(gs->persistent_memory, 1, sizeof(struct Button));
-    b->type = type;
-    b->texture = texture;
-    SDL_QueryTexture(texture, NULL, NULL, &b->w, &b->h);
-
-    strcpy(b->tooltip_text, tooltip_text);
-    b->on_pressed = on_pressed;
-    return b;
-}
-
-void click_gui_tool_button(void *type_ptr) {
-    int type = *((int*)type_ptr);
-    
-    struct GUI *gui = &gs->gui;
-
-    if (gui->popup) return;
-
-    gs->current_tool = type;
-    gs->chisel_blocker_mode = 0;
-    switch (gs->current_tool) {
-    case TOOL_CHISEL_SMALL:
-        gs->chisel = &gs->chisel_small;
-        for (int i = 0; i < gs->object_count; i++)
-            object_generate_blobs(i, 0);
-        gs->chisel_hammer.normal_dist = gs->chisel_hammer.dist = (f32) (gs->chisel->w+2);
-        break;
-    case TOOL_CHISEL_MEDIUM:
-        gs->chisel = &gs->chisel_medium;
-        for (int i = 0; i < gs->object_count; i++)
-            object_generate_blobs(i, 1);
-        gs->chisel_hammer.normal_dist = gs->chisel_hammer.dist = (f32) (gs->chisel->w+4);
-        break;
-    case TOOL_CHISEL_LARGE:
-        gs->current_tool = TOOL_CHISEL_LARGE;
-        gs->chisel = &gs->chisel_large;
-        for (int i = 0; i < gs->object_count; i++)
-            object_generate_blobs(i, 2);
-        gs->chisel_hammer.normal_dist = gs->chisel_hammer.dist = (f32) (gs->chisel->w+4);
-        break;
-    }
-
-    for (int i = 0; i < TOOL_COUNT; i++) {
-        gui->tool_buttons[i]->activated = 0;
-    }
-    tooltip_reset(&gui->tooltip);
-}
-
-void button_tick(struct Button *b, void *data) {
-    struct Input *input = &gs->input;
-    struct GUI *gui = &gs->gui;
-
-    int gui_input_mx = input->real_mx;
-    int gui_input_my = input->real_my;
-
-    // TODO: This is a temporary hack so that function pointers won't stop working
-    //       upon reloading the DLL.
-    switch (b->type) {
-    case BUTTON_TYPE_CONVERTER:
-        b->on_pressed = converter_begin_converting;
-        break;
-    case BUTTON_TYPE_TOOL_BAR:
-        b->on_pressed = click_gui_tool_button;
-        break;
-    }
-
-    if (gui_input_mx >= b->x && gui_input_mx < b->x+b->w &&
-        gui_input_my >= b->y && gui_input_my < b->y+b->h) {
-
-        tooltip_set_position_to_cursor(&gui->tooltip, TOOLTIP_TYPE_BUTTON);
-        b->just_had_tooltip = true;
-
-        if (strlen(b->tooltip_text))
-            strcpy(gui->tooltip.str[0], b->tooltip_text);
-
-        if (input->mouse_pressed[SDL_BUTTON_LEFT]) {
-            b->on_pressed(data);
-            b->activated = true;
-        }
-    } else if (b->just_had_tooltip) {
-        b->just_had_tooltip = false;
-        tooltip_reset(&gui->tooltip);
-    }
-
-    if (!(input->mouse & SDL_BUTTON(SDL_BUTTON_LEFT))) {
-        b->activated = false;
-    }
-}
-
-void button_draw(struct Button *b) {
-    struct Input *input = &gs->input;
-
-    int gui_input_mx = input->real_mx;// / gs->S;
-    int gui_input_my = input->real_my;// / gs->S;
-
-    SDL_Rect dst = {
-        b->x, b->y, b->w, b->h
-    };
-    if (b->activated) {
-        SDL_SetTextureColorMod(b->texture, 200, 200, 200);
-    } else if (gui_input_mx >= b->x && gui_input_mx < b->x+b->w &&
-               gui_input_my >= b->y && gui_input_my < b->y+b->h) {
-        SDL_SetTextureColorMod(b->texture, 230, 230, 230);
-    } else {
-        SDL_SetTextureColorMod(b->texture, 255, 255, 255);
-    }
-    SDL_RenderCopy(gs->renderer, b->texture, NULL, &dst);
-}
-
-void gui_init() {
-    struct GUI *gui = &gs->gui;
-
-    gui->popup_y = (f32) (gs->gh*gs->S);
-    gui->popup_y_vel = 0;
-    gui->popup_h = GUI_POPUP_H;
-    gui->popup = 0;
-    gui->popup_texture = gs->textures.popup;
-
-    tooltip_reset(&gui->tooltip);
-    gui->is_placer_active = false;
-
-    int cum = 0;
-
-    for (int i = 0; i < TOOL_COUNT; i++) {
-        char name[128] = {0};
-        get_name_from_tool(i, name);
-
-        if (gui->tool_buttons[i] == NULL) {
-            gui->tool_buttons[i] = button_allocate(BUTTON_TYPE_TOOL_BAR, gs->textures.tool_buttons[i], name, click_gui_tool_button);
-        }
-        gui->tool_buttons[i]->x = cum;
-        gui->tool_buttons[i]->y = 0;
-        gui->tool_buttons[i]->index = i;
-        gui->tool_buttons[i]->activated = i == gs->current_tool;
-
-        cum += gui->tool_buttons[i]->w;
-    }
-}
-
-void gui_tick() {
-    struct GUI *gui = &gs->gui;
-    struct Input *input = &gs->input;
-
-    if (input->keys_pressed[SDL_SCANCODE_TAB]) {
-        gui->popup = !gui->popup;
-        gui->popup_y_vel = 0;
-        tooltip_reset(&gui->tooltip);
-
-        gs->current_tool = gs->previous_tool;
-
-        // Just in case the player had reset it.
-        if (gs->current_placer == -1)
-            gs->current_placer = 0;
-    }
-
-    const f32 speed = 3.0f;
-
-    if (gui->popup) {
-        if (SDL_GetCursor() != gs->grabber_cursor) {
-            /* SDL_SetCursor(gs->grabber_cursor); */
-            /* SDL_ShowCursor(1); */
-        }
-
-        if (gui->popup_y > gs->S*gs->gh-gui->popup_h) {
-            gui->popup_y_vel -= speed;
-        } else {
-            gui->popup_y_vel = 0;
-            gui->popup_y = gs->S*gs->gh-gui->popup_h;
-        }
-
-        int was_placer_active = gui->is_placer_active;
-
-        gui->is_placer_active = input->keys[SDL_SCANCODE_LCTRL];
-
-        if (was_placer_active && !gui->is_placer_active) {
-            tooltip_reset(&gui->tooltip);
-        } else if (!was_placer_active && gui->is_placer_active) {
-            struct Placer *p = converter_get_current_placer();
-            p->x = input->mx;
-            p->y = input->my;
-        }
-    } else if (gui->popup_y < gs->S*gs->gh) {
-        gui->popup_y_vel += speed;
-    } else {
-        gui->popup_y = (f32) (gs->S*gs->gh);
-        gui->popup_y_vel = 0;
-    }
-
-    if (!gui->popup) {
-        /* SDL_SetCursor(normal_cursor); */
-        for (int i = 0; i < TOOL_COUNT; i++) {
-            button_tick(gui->tool_buttons[i], &i);
-        }
-        if (input->real_my >= GUI_H) {
-            // tooltip_reset(&gui->tooltip);
-        }
-    }
-
-    gui->popup_y += gui->popup_y_vel;
-    gui->popup_y = (f32) clamp((int) gui->popup_y, (int) (gs->S*gs->gh - gui->popup_h), gs->window_height);
-}
-
-void gui_draw() {
-    struct GUI *gui = &gs->gui;
-
-    // Draw the toolbar buttons.
-    SDL_Texture *old = SDL_GetRenderTarget(gs->renderer);
-
-    SDL_SetTextureBlendMode(RenderTarget(RENDER_TARGET_GUI_TOOLBAR), SDL_BLENDMODE_BLEND);
-
-    Assert(RenderTarget(RENDER_TARGET_GUI_TOOLBAR));
-    SDL_SetRenderTarget(gs->renderer, RenderTarget(RENDER_TARGET_GUI_TOOLBAR));
-
-    SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 0);
-    SDL_RenderClear(gs->renderer);
-
-    SDL_SetRenderDrawColor(gs->renderer, 64, 64, 64, 255);
-    SDL_Rect r = { 0, 0, gs->gw, GUI_H/gs->S };
-    SDL_RenderFillRect(gs->renderer, &r);
-
-    for (int i = 0; i < TOOL_COUNT; i++) {
-        button_draw(gui->tool_buttons[i]);
-    }
-
-    SDL_Rect dst = {
-        0, 0,
-        gs->gw*gs->S, GUI_H
-    };
-
-    SDL_SetRenderTarget(gs->renderer, NULL);
-    SDL_RenderCopy(gs->renderer, RenderTarget(RENDER_TARGET_GUI_TOOLBAR), NULL, &dst);
-    SDL_SetRenderTarget(gs->renderer, old);
-}
-
-void gui_popup_draw() {
-    struct GUI *gui = &gs->gui;
-
-    SDL_Rect popup = {
-        0, (int)(GUI_H + gui->popup_y),
-        gs->gw*gs->S, (int)gui->popup_h
-    };
-
-    SDL_SetRenderDrawColor(gs->renderer, 255, 255, 255, 255);
-    SDL_RenderFillRect(gs->renderer, &popup);
-}
-
-bool is_cell_fuel(int type) {
-    switch (type) {
-    case CELL_REFINED_COAL: case CELL_UNREFINED_COAL: case CELL_LAVA:
-        return true;
-    }
-    return false;
-}
-
-bool is_cell_stone(int type) {
-    switch (type) {
-    case CELL_COBBLESTONE: case CELL_MARBLE: case CELL_SANDSTONE:
-    case CELL_CONCRETE: case CELL_QUARTZ: case CELL_GRANITE:
-    case CELL_BASALT: case CELL_DIAMOND:
-        return true;
-    default:
-        return false;
-    }
-}
-
-// Possibilities:
-//   Tiers 1, 2, or 3.
-//   Returns 0 if no tier is specified.
-int get_cell_tier(int type) {
-    switch (type) {
-    case CELL_MARBLE: case CELL_COBBLESTONE: case CELL_SANDSTONE:
-        return 1;
-        break;
-    case CELL_CEMENT: case CELL_CONCRETE: case CELL_QUARTZ: case CELL_GLASS:
-        return 2;
-        break;
-    case CELL_GRANITE: case CELL_BASALT: case CELL_DIAMOND: // case CELL_GOLD:
-        return 3;
-        break;
-
-    case CELL_UNREFINED_COAL:
-        return 1;
-    case CELL_REFINED_COAL:
-        return 2;
-    case CELL_LAVA:
-        return 3;
-    }
-
-    return 0; // 0 = not specified in any tier.
-}
-
-bool can_place_item_in_slot(int type, int slot) {
-    bool can_put_fuel = false;
-    
-    if (slot == SLOT_FUEL) {
-        can_put_fuel = is_cell_fuel(type);
-    }
-    
-    return
-        slot == SLOT_INPUT1 ||
-        slot == SLOT_INPUT2 ||
-        can_put_fuel;
-}
-
-bool is_mouse_in_slot(struct Slot *slot) {
-    struct Input *input = &gs->input;
-    
-    return is_point_in_rect((SDL_Point){input->real_mx, input->real_my-GUI_H},
-                            (SDL_Rect){
-                                (int) (slot->converter->x + slot->x - slot->w/2),
-                                (int) (slot->converter->y + slot->y - slot->h/2),
-                                (int) slot->w,
-                                (int) slot->h
-                            });
-}
-
-bool was_mouse_in_slot(struct Slot *slot) {
-    struct Input *input = &gs->input;
-    
-    return is_point_in_rect((SDL_Point){input->real_pmx,input->real_pmy-GUI_H},
-                            (SDL_Rect){
-                                (int) (slot->converter->x + slot->x - slot->w/2),
-                                (int) (slot->converter->y + slot->y - slot->h/2),
-                                (int) slot->w,
-                                (int) slot->h
-                            });
-}
-
-bool is_mouse_in_converter(struct Converter *converter) {
-    struct Input *input = &gs->input;
-    
-    return is_point_in_rect((SDL_Point){
-            input->real_mx,
-            input->real_my-GUI_H
-        },
-        (SDL_Rect){
-            (int)converter->x,
-            (int)converter->y,
-            (int)converter->w,
-            (int)converter->h
-        });
-}
-
-// Slot may be NULL if the item doesn't belong to any slot.
-// This function mostly just handles interactions with items and the mouse.
-void item_tick(struct Item *item, struct Slot *slot, int x, int y, int w, int h) {
-    struct Input *input = &gs->input;
-
-    if (item == &gs->item_holding) {
-        if (input->real_my < gs->gui.popup_y && input->mouse_pressed[SDL_BUTTON_LEFT]) {
-            // We pressed outside of the converter area.
-            // We will now kill the holding item.
-            gs->item_holding.type = 0;
-            gs->item_holding.amount = 0;
-        }
-        return;
-    }    
-
-    if (!is_point_in_rect((SDL_Point){input->real_mx, input->real_my-GUI_H}, (SDL_Rect){x, y, w, h})) return;
-    
-    // From this point onwards, we know the mouse is in this item,
-    // and this item is not currently being held.
-    
-    bool can_place_item = false;
-    
-    if (!gs->gui.is_placer_active) {
-        can_place_item = can_place_item_in_slot(gs->item_holding.type, slot->type);
-        if (!gs->item_holding.type) can_place_item = true;
-        
-        if (input->mouse_pressed[SDL_BUTTON_LEFT]) {
-            // If they're the same type, just add their amounts.
-            if (item->type && gs->item_holding.type == item->type) {
-                // Add the amount from holding to the item.
-                item->amount += gs->item_holding.amount;
-                
-                gs->item_holding.type = 0;
-                gs->item_holding.amount = 0;
-            }
-            
-            // Otherwise if we're either holding an item or have an item in slot,
-            // swap them since they're different types.
-            else if ((gs->item_holding.type || item->type) && can_place_item) {
-                struct Item a = *item;
-                
-                item->type = gs->item_holding.type;
-                item->amount = gs->item_holding.amount;
-                
-                gs->item_holding.type = a.type;
-                gs->item_holding.amount = a.amount;
-                
-                tooltip_reset(&gs->gui.tooltip);
-            } 
-            
-        } else if (input->mouse_pressed[SDL_BUTTON_RIGHT] && item->type && gs->item_holding.type == 0) { // If holding nothing
-            // Split the item into two like minecraft.
-            Assert(gs->item_holding.amount == 0);
-            
-            const int half = item->amount/2;
-            
-            if (half) {
-                item->amount -= half;
-                gs->item_holding.type = item->type;
-                gs->item_holding.amount += half;
-                
-                tooltip_reset(&gs->gui.tooltip);
-            }
-        }
-    } else if (gs->gui.is_placer_active) {
-        struct Placer *p = converter_get_current_placer();
-        struct Converter *converter = NULL;
-        
-        can_place_item = can_place_item_in_slot(p->contains_type, slot->type);
-        
-        if (is_mouse_in_converter(gs->material_converter)) {
-            converter = gs->material_converter;
-        } else if (is_mouse_in_converter(gs->fuel_converter)) {
-            converter = gs->fuel_converter;
-        }
-        
-        if (input->mouse_pressed[SDL_BUTTON_RIGHT]) {
-            if (p->contains_amount == 0) p->contains_type = 0;
-            if (p->contains_type == 0 || p->contains_type == item->type) {
-                p->contains_type = item->type;
-                p->contains_amount += item->amount;
-                
-                item->type = 0;
-                item->amount = 0;
-            }
-        } else if (can_place_item && input->mouse & SDL_BUTTON_LEFT) {
-            int amt = 0;
-            const int place_speed = 6;
-            
-            if (p->contains_amount && (!item->type || !item->amount)) {
-                item->type = p->contains_type;
-                amt = place_speed;
-            } else if (item->type == p->contains_type) {
-                amt = place_speed;
-            }
-            
-            if (p->contains_amount - converter->speed < 0) {
-                amt = p->contains_amount;
-            }
-            
-            item->amount += amt;
-            p->contains_amount -= amt;
-        }
-    }
-}
-
-void slot_tick(struct Slot *slot) {
-    item_tick(&slot->item,
-              slot,
-              (int) (slot->converter->x + slot->x - slot->w/2),
-              (int) (slot->converter->y + slot->y - slot->h/2),
-              (int) slot->w,
-              (int) slot->h);
-}
-
-void item_draw(struct Item *item, int x, int y, int w, int h) {
-    if (!item->type) return;
-    if (!item->amount) {
-        item->type = 0;
-        return;
-    }
-    
-    SDL_Rect r = {
-        x, y,
-        w, h
-    };
-    SDL_RenderCopy(gs->renderer, gs->textures.items[item->type], NULL, &r);
-    
-    char number[32] = {0};
-    sprintf(number, "%d", item->amount);
-    
-    SDL_Color color = (SDL_Color){255, 255, 255, 255};
-    
-    SDL_Surface *surf = TTF_RenderText_Solid(gs->fonts.font_bold_small, number, color);
-    SDL_Texture *texture = SDL_CreateTextureFromSurface(gs->renderer, surf);
-    
-    SDL_Rect dst = {
-        x + w - surf->w - 1,
-        y + h - surf->h - 1,
-        surf->w,
-        surf->h
-    };
-    
-    SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 255);
-    SDL_RenderFillRect(gs->renderer, &dst);
-    
-    SDL_RenderCopy(gs->renderer, texture, NULL, &dst);
-
-    SDL_FreeSurface(surf);
-    SDL_DestroyTexture(texture);
-}
-
-void slot_draw(struct Slot *slot) {
-    struct Converter *c = slot->converter;
-    SDL_Rect bounds = {
-        (int) (c->x + slot->x - slot->w/2),
-        (int) (c->y + slot->y - slot->h/2 + GUI_H),
-        (int) slot->w,
-        (int) slot->h
-    };
-    
-    int col = 200;
-    SDL_SetRenderDrawColor(gs->renderer, col, col, col, 255);
-    SDL_RenderFillRect(gs->renderer, &bounds);
-    
-    col = 0;
-    SDL_SetRenderDrawColor(gs->renderer, col, col, col, 255);
-    
-    bounds.x--;
-    bounds.y--;
-    bounds.w += 2;
-    bounds.h += 2;
-    
-    SDL_RenderDrawRect(gs->renderer, &bounds);
-    
-    bounds.x++;
-    bounds.y++;
-    bounds.w -= 2;
-    bounds.h -= 2;
-    
-    if (*slot->name) {
-        SDL_Surface **surf = &gs->surfaces.slot_names[SLOT_MAX_COUNT * c->type + slot->type];
-        SDL_Texture **texture = &gs->textures.slot_names[SLOT_MAX_COUNT * c->type + slot->type];
-        
-        if (!*surf) {
-            *surf = TTF_RenderText_Blended(gs->fonts.font_small, slot->name, (SDL_Color){0, 0, 0, 255});
-        }
-        Assert(*surf);
-
-        if (!*texture) {
-            *texture = SDL_CreateTextureFromSurface(gs->renderer, *surf);
-        }
-
-        Assert(*texture);
-        
-        SDL_Rect dst = {
-            (int) (bounds.x + slot->w/2 - (*surf)->w/2),
-            (int) (bounds.y - (*surf)->h - 2),
-            (*surf)->w,
-            (*surf)->h
-        };
-        SDL_RenderCopy(gs->renderer, *texture, NULL, &dst);
-    }
-    
-    item_draw(&slot->item, bounds.x, bounds.y, bounds.w, bounds.h);
-}
-
-//////////////////////////////////////////
-
-struct Converter *converter_init(int type, bool allocated) {
-    struct Converter *converter = NULL;
-
-    if (!allocated) {
-        converter = arena_alloc(gs->persistent_memory, 1, sizeof(struct Converter));
-    } else {
-        switch (type) {
-        case CONVERTER_FUEL:
-            converter = gs->fuel_converter;
-            break;
-        case CONVERTER_MATERIAL:
-            converter = gs->material_converter;
-            break;
-        }
-    }
-    
-    converter->type = type;
-    converter->w = (f32) (gs->window_width/2);
-    converter->h = GUI_POPUP_H;
-    
-    converter->timer_max = 1;
-    converter->timer_current = 0;
-    
-    switch (type) {
-    case CONVERTER_MATERIAL:
-        converter->slot_count = 4;
-
-        if (!allocated) {
-            converter->slots = arena_alloc(gs->persistent_memory, converter->slot_count, sizeof(struct Slot));
-        }
-        
-        converter->slots[SLOT_INPUT1].x = converter->w/3.f;
-        converter->slots[SLOT_INPUT1].y = converter->h/4.f;
-        strcpy(converter->slots[SLOT_INPUT1].name, "Inp. 1");
-        
-        converter->slots[SLOT_INPUT2].x = 2.f*converter->w/3.f;
-        converter->slots[SLOT_INPUT2].y = converter->h/4.f;
-        strcpy(converter->slots[SLOT_INPUT2].name, "Inp. 2");
-        
-        converter->slots[SLOT_FUEL].x = 3.f*converter->w/4.f;
-        converter->slots[SLOT_FUEL].y = converter->h/2.f;
-        strcpy(converter->slots[SLOT_FUEL].name, "Fuel");
-        
-        converter->slots[SLOT_OUTPUT].x = converter->w/2.f;
-        converter->slots[SLOT_OUTPUT].y = 4.f*converter->h/5.f;
-        strcpy(converter->slots[SLOT_OUTPUT].name, "Output");
-        
-        strcpy(converter->name, "Material Converter");
-        break;
-    case CONVERTER_FUEL:
-        converter->slot_count = 3;
-
-        if (!allocated) {
-            converter->slots = arena_alloc(gs->persistent_memory, converter->slot_count, sizeof(struct Slot));
-        }
-        
-        converter->slots[SLOT_INPUT1].x = converter->w/3.f;
-        converter->slots[SLOT_INPUT1].y = converter->h/4.f;
-        strcpy(converter->slots[SLOT_INPUT1].name, "Inp. 1");
-        
-        converter->slots[SLOT_INPUT2].x = 2.f*converter->w/3.f;
-        converter->slots[SLOT_INPUT2].y = converter->h/4.f;
-        strcpy(converter->slots[SLOT_INPUT2].name, "Inp. 2");
-        
-        converter->slots[SLOT_OUTPUT].x = converter->w/2.f;
-        converter->slots[SLOT_OUTPUT].y = 4.f*converter->h/5.f;
-        strcpy(converter->slots[SLOT_OUTPUT].name, "Output");
-        
-        strcpy(converter->name, "Fuel Converter");
-        break;
-    }
-    
-    // Indices line up with Slot_Type enum
-    // even though slot_count is variable.
-    for (int i = 0; i < converter->slot_count; i++) {
-        converter->slots[i].type = i;
-        converter->slots[i].w = ITEM_SIZE;
-        converter->slots[i].h = ITEM_SIZE;
-        converter->slots[i].converter = converter;
-    }
-    
-    converter->arrow.texture = gs->textures.converter_arrow;
-    SDL_QueryTexture(converter->arrow.texture, NULL, NULL, &converter->arrow.w, &converter->arrow.h);
-    
-    converter->arrow.x = (int) (converter->w/2);
-    converter->arrow.y = (int) (converter->h/2 + 24);
-    converter->speed = 8;
-    
-    // Both X and Y-coordinates are updated in converter_tick.
-    if (converter->go_button == NULL) {
-        converter->go_button = button_allocate(BUTTON_TYPE_CONVERTER, gs->textures.convert_button, "Convert", converter_begin_converting);
-    }
-    converter->go_button->w = 48;
-    converter->go_button->h = 48;
-    
-    return converter;
-}
-
-void all_converters_init() {
-    bool allocated = gs->material_converter != NULL || gs->fuel_converter != NULL;
-    gs->material_converter = converter_init(CONVERTER_MATERIAL, allocated);
-    gs->fuel_converter = converter_init(CONVERTER_FUEL, allocated);
-}
-
-int get_number_unique_inputs(struct Item *input1, struct Item *input2) {
-    int number_inputs = (input1->type != 0) + (input2->type != 0);
-    int number_unique_inputs = 0;
-
-    if (number_inputs == 1) {
-        number_unique_inputs = 1;
-    } else if (number_inputs == 2) {
-        if (input1->type != input2->type) {
-            number_unique_inputs = 2;
-        } else {
-            number_unique_inputs = 1;
-        }
-    }
-
-    return number_unique_inputs;
-}
-
-struct Converter_Checker converter_checker(struct Item *input1, struct Item *input2) {
-    Assert(input1);
-    Assert(input2);
-
-    return (struct Converter_Checker) {
-        input1, input2, 0
-    };
-}
-
-bool is_either_input_type(struct Converter_Checker *checker, int type, bool restart) {
-    Assert(checker->input1);
-    Assert(checker->input2);
-
-    if (restart) {
-        checker->current = 0;
-    }
-
-    if (checker->current == 0) {
-        if (checker->input1->type == type) {
-            checker->current = 2;
-        } else if (checker->input2->type == type) {
-            checker->current = 1;
-        } else {
-            return false;
-        }
-    } else {
-        if ((checker->current == 2 && checker->input2->type != type) ||
-            (checker->current == 1 && checker->input1->type != type)) {
-            return false;
-        }
-    }
-
-    return true;
-}
-
-bool is_either_input_tier(struct Converter_Checker *checker, int tier, bool is_fuel, bool restart) {
-    Assert(checker->input1);
-    Assert(checker->input2);
-
-    if (restart) {
-        checker->current = 0;
-    }
-
-    if (checker->current == 0) {
-        if (get_cell_tier(checker->input1->type) == tier) {
-            checker->current = 2;
-        } else if (get_cell_tier(checker->input2->type) == tier) {
-            checker->current = 1;
-        }
-    } else {
-        if (is_fuel) {
-            return ((checker->current == 2 && is_cell_fuel(checker->input2->type) && tier == get_cell_tier(checker->input2->type)) ||
-                    (checker->current == 1 && is_cell_fuel(checker->input1->type) && tier == get_cell_tier(checker->input1->type)));
-        } else {
-            return ((checker->current == 2 && !is_cell_fuel(checker->input2->type) && tier == get_cell_tier(checker->input2->type)) ||
-                    (checker->current == 1 && !is_cell_fuel(checker->input1->type) && tier == get_cell_tier(checker->input1->type)));
-        }
-    }
-
-    return true;
-}
-
-bool is_either_input_stone(struct Converter_Checker *checker, bool restart) {
-    Assert(checker->input1);
-    Assert(checker->input2);
-
-    if (restart) {
-        checker->current = 0;
-    }
-
-    if (checker->current == 0) {
-        if (is_cell_stone(checker->input1->type)) {
-            checker->current = 2;
-        } else if (is_cell_stone(checker->input2->type)) {
-            checker->current = 1;
-        }
-    } else {
-        if ((checker->current == 2 && !is_cell_stone(checker->input2->type)) ||
-            (checker->current == 1 && !is_cell_stone(checker->input1->type))) {
-            return false;
-        }
-    }
-
-    return true;
-}
-
-// Calculate the ratio of inputs -> output.
-f32 calculate_output_ratio(struct Item *input1, struct Item *input2) {
-    f32 result = 0.f;
-    int number_unique_inputs = get_number_unique_inputs(input1, input2);
-
-    result = (f32) (number_unique_inputs * number_unique_inputs);
-
-    return result;
-}
-
-int fuel_converter_convert(struct Item *input1, struct Item *input2) {
-    int result_type = 0;
-    int number_inputs = (input1->type != 0) + (input2->type != 0);
-    int number_unique_inputs = 0;
-
-    struct Item *input = NULL;
-
-    if (number_inputs == 1) {
-        input = input1->type ? input1 : input2;
-    } else if (number_inputs == 2) {
-        input = input1;
-    }
-
-    number_unique_inputs = get_number_unique_inputs(input1, input2);
-
-    if (number_unique_inputs == 1) {
-        if (input->type == CELL_DIRT ||
-            input->type == CELL_SAND ||
-            !is_cell_fuel(input->type) && get_cell_tier(input->type) == 1)
-        {
-            result_type = CELL_UNREFINED_COAL;
-        }
-    }
-    else if (number_unique_inputs == 2) {
-        struct Converter_Checker checker = converter_checker(input1, input2);
-
-        if (is_either_input_type(&checker, CELL_UNREFINED_COAL, false) &&
-            is_either_input_tier(&checker, 2, false, false))
-        {
-            result_type = CELL_REFINED_COAL;
-        }
-
-        else if (is_either_input_type(&checker, CELL_UNREFINED_COAL, true) &&
-                 is_either_input_type(&checker, CELL_LAVA, false))
-        {
-            result_type = CELL_REFINED_COAL; // TODO: Higher output ratio.
-        }
-
-        else if (is_either_input_type(&checker, CELL_REFINED_COAL, true) &&
-                 is_either_input_stone(&checker, false))
-        {
-            result_type = CELL_LAVA;
-        }
-    }
-
-    return result_type;
-}
-
-int material_converter_convert(struct Item *input1, struct Item *input2, struct Item *fuel) {
-    Assert(input1);
-    Assert(input2);
-
-    int result_type = 0;
-    int number_inputs = (input1->type != 0) + (input2->type != 0);
-
-    // TOOD: Turn this into number_unique_inputs? Won't this not work
-    //       with that?
-
-    struct Item *input = NULL;
-
-    if (number_inputs == 1) {
-        input = input1->type ? input1 : input2;
-    } else if (number_inputs == 2) {
-        input = input1;
-    }
-    
-    switch (fuel->type) {
-    case CELL_NONE:
-        switch (input->type) {
-        case CELL_WOOD_LOG:
-            result_type = CELL_WOOD_PLANK;
-            break;
-        }
-        break;
-    case CELL_UNREFINED_COAL:
-        if (number_inputs == 2) {
-            struct Converter_Checker checker = converter_checker(input1, input2);
-
-            if (is_either_input_type(&checker, CELL_COBBLESTONE, true) &&
-                is_either_input_type(&checker, CELL_SAND, false))
-            {
-                result_type = CELL_SANDSTONE;
-            }
-        } else if (number_inputs == 1) {
-            switch (input->type) {
-            case CELL_SAND:
-                result_type = CELL_GLASS;
-                break;
-            case CELL_DIRT:
-                result_type = CELL_COBBLESTONE;
-                break;
-            case CELL_COBBLESTONE:
-                result_type = CELL_MARBLE;
-                break;
-            case CELL_ICE:
-                result_type = CELL_WATER;
-                break;
-            case CELL_WATER:
-                result_type = CELL_STEAM;
-                break;
-            }
-        }
-        break;
-    case CELL_REFINED_COAL:
-        if (number_inputs == 1) {
-            switch (input->type) {
-            case CELL_DIRT:
-                result_type = CELL_COBBLESTONE;
-                break;
-            case CELL_ICE:
-                result_type = CELL_STEAM;
-                break;
-            }
-        } else if (number_inputs == 2) {
-            struct Converter_Checker checker = converter_checker(input1, input2);
-
-            if (is_either_input_type(&checker, CELL_SANDSTONE, true) &&
-                is_either_input_type(&checker, CELL_MARBLE, false))
-            {
-                result_type = CELL_QUARTZ;
-            }
-            else if (is_either_input_type(&checker, CELL_WATER, true) &&
-                     is_either_input_type(&checker, CELL_COBBLESTONE, false))
-            {
-                result_type = CELL_CEMENT;
-            }
-        }
-
-        break;
-    case CELL_LAVA:
-        if (number_inputs == 1) {
-            switch (input->type) {
-            case CELL_REFINED_COAL: case CELL_UNREFINED_COAL:
-                result_type = CELL_BASALT;
-                break;
-            }
-        } else if (number_inputs == 2) {
-            struct Converter_Checker checker = converter_checker(input1, input2);
-
-            if (is_either_input_type(&checker, CELL_QUARTZ, true) &&
-                is_either_input_type(&checker, CELL_MARBLE, false))
-            {
-                result_type = CELL_GRANITE;
-            }
-            else if (is_either_input_type(&checker, CELL_BASALT, true) &&
-                     is_either_input_type(&checker, CELL_GRANITE, false))
-            {
-                result_type = CELL_DIAMOND;
-            }
-        }
-        break;
-    }
-    
-    return result_type;
-}
-
-// Returns if the conversion went succesfully.
-bool converter_convert(struct Converter *converter) {
-    bool did_convert = false;
-
-    int temp_output_type = 0;
-
-    struct Item *input1 = &converter->slots[SLOT_INPUT1].item;
-    struct Item *input2 = &converter->slots[SLOT_INPUT2].item;
-    struct Item *output = &converter->slots[SLOT_OUTPUT].item;
-    struct Item *fuel = NULL;
-
-    if (converter->type == CONVERTER_MATERIAL) {
-        fuel = &converter->slots[SLOT_FUEL].item;
-    }
-
-    int number_inputs = (input1->type != 0) + (input2->type != 0);
-
-    if (!number_inputs) return false;
-    /* if (fuel && (!fuel->type || fuel->amount == 0)) return false; */
-
-    if (converter->type == CONVERTER_FUEL) {
-        temp_output_type = fuel_converter_convert(input1, input2);
-    } else if (converter->type == CONVERTER_MATERIAL) {
-        temp_output_type = material_converter_convert(input1, input2, fuel);
-    }
-
-    if (!temp_output_type) return false;
-
-    f32 output_ratio = calculate_output_ratio(input1, input2);
-
-    bool final_conversion = false;
-
-    // Actually remove amounts from the inputs and increase
-    // or set the output.
-    if (temp_output_type == output->type || output->type == 0) {
-        output->type = temp_output_type;
-
-        int amount = (int) (converter->speed * output_ratio);
-
-        // Check if any input, when reduced by the amount,
-        // gives negative amount. If so, lock the amount
-        // we're reducing to by the correct amount.
-        if (input1->type && input1->amount-amount < 0) {
-            amount = input1->amount;
-            final_conversion = true;
-        }
-        if (input2->type && input2->amount-amount < 0) {
-            amount = input2->amount;
-            final_conversion = true;
-        }
-
-        // The same for fuel, but make sure to multiple by the
-        // number of inputs to compensate otherwise you'd be able
-        // to use half the amount of fuel for the same output if
-        // you just split the input in two.
-        if (fuel && fuel->type && fuel->amount-amount < 0) {
-            amount = fuel->amount * number_inputs; // *ing to compensate.
-            final_conversion = true;
-        }
-
-        int amount_add = 0;
-        if (input1->type) {
-            input1->amount -= amount;
-            amount_add += amount;
-        }
-        if (input2->type) {
-            input2->amount -= amount;
-            amount_add += amount;
-        }
-
-        if (fuel && fuel->type)
-            fuel->amount -= amount_add;
-        output->amount += amount_add;
-
-        did_convert = true;
-    }
-
-    return !final_conversion || !did_convert;
-}
-
-void converter_tick(struct Converter *converter) {
-    converter->arrow.y = (int) (converter->h/2 + 18);
-    
-    switch (converter->type) {
-    case CONVERTER_MATERIAL:
-        converter->x = 0;
-        converter->y = gs->gui.popup_y;
-        break;
-    case CONVERTER_FUEL:
-        converter->x = (f32) (gs->S*gs->gw/2);
-        converter->y = (f32) (gs->gui.popup_y);
-        break;
-    }
-    
-    converter->go_button->x = (int) (converter->x + converter->arrow.x - 128);
-    converter->go_button->y = (int) (gs->gui.popup_y + 240);
-    
-    for (int i = 0; i < converter->slot_count; i++) {
-        struct Slot *s = &converter->slots[i];
-        slot_tick(s);
-    }
-    
-    button_tick(converter->go_button, converter);
-    
-    if (converter->state == CONVERTER_ON) {
-        if (converter->timer_current < converter->timer_max) {
-            converter->timer_current += 1;
-        } else {
-            converter->timer_current = 0;
-            switch (converter->type) {
-            case CONVERTER_MATERIAL: {
-                bool did_convert = converter_convert(gs->material_converter);
-                if (!did_convert) {
-                    converter_set_state(gs->material_converter, CONVERTER_OFF);
-                }
-                break;
-            }
-            case CONVERTER_FUEL: {
-                bool did_convert = converter_convert(gs->fuel_converter);
-                if (!did_convert) {
-                    converter_set_state(gs->fuel_converter, CONVERTER_OFF);
-                }
-                break;
-            }
-            }
-        }
-    }
-    
-    if (!gs->gui.popup) return;
-}
-
-void all_converters_tick() {
-    if (gs->gui.popup && gs->current_tool != TOOL_PLACER) {
-        gs->previous_tool = gs->current_tool;
-        gs->current_tool = TOOL_PLACER;
-    }
-    
-    if (gs->gui.popup && gs->gui.is_placer_active) {
-        placer_tick(converter_get_current_placer());
-    }
-    
-    converter_tick(gs->material_converter);
-    converter_tick(gs->fuel_converter);
-    
-    if (!gs->gui.is_placer_active) {
-        bool set_tooltip_this_frame = false;
-        
-        for (int i = 0; i < 2; i++) {
-            struct Converter *c = i == 0 ? gs->material_converter : gs->fuel_converter;
-            
-            for (int j = 0; j < c->slot_count; j++) {
-                if (!c->slots[j].item.type) continue;
-                
-                if (is_mouse_in_slot(&c->slots[j])) {
-                    tooltip_set_position_to_cursor(&gs->gui.tooltip, TOOLTIP_TYPE_ITEM);
-                    
-                    char type[64] = {0};
-                    char type_name[64] = {0};
-                    char amount[64] = {0};
-                    
-                    get_name_from_type(c->slots[j].item.type, type_name);
-                    sprintf(type, "Type: %s", type_name);
-                    sprintf(amount, "Amount: %d", c->slots[j].item.amount);
-                    
-                    strcpy(gs->gui.tooltip.str[0], type);
-                    strcpy(gs->gui.tooltip.str[1], amount);
-                    
-                    set_tooltip_this_frame = true;
-                } else if (!set_tooltip_this_frame && gs->gui.tooltip.type == TOOLTIP_TYPE_ITEM) {
-                    tooltip_reset(&gs->gui.tooltip);
-                }
-            }
-        }
-    }
-    
-    struct Input *input = &gs->input;
-    item_tick(&gs->item_holding, NULL, input->real_mx, input->real_my, ITEM_SIZE, ITEM_SIZE);
-}
-
-void converter_draw(struct Converter *converter) {
-    SDL_Rect converter_bounds = {
-        (int)converter->x, (int)converter->y + GUI_H,
-        (int)converter->w, (int)converter->h
-    };
-    
-    SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 255);
-    SDL_RenderDrawRect(gs->renderer, &converter_bounds);
-    
-    for (int i = 0; i < converter->slot_count; i++) {
-        slot_draw(&converter->slots[i]);
-    }
-    
-    SDL_Rect arrow_dst = {
-        (int) (converter->x + converter->arrow.x - converter->arrow.w / 2.0),
-        (int) (converter->y + converter->arrow.y + converter->arrow.h / 2.0),
-        converter->arrow.w,
-        converter->arrow.h
-    };
-    
-    // Flashing the arrow itself.
-    if (converter->state == CONVERTER_ON) {
-        const int period = 500; // Milliseconds.
-        Uint8 a = (SDL_GetTicks()/period) % 2 == 0;
-        a = a ? 255 : 190;
-
-        SDL_SetTextureColorMod(converter->arrow.texture, a, a, a);
-    }
-    // Since we use the same texture for both converters,
-    // we need to reset it every time as well.
-    else {
-        SDL_SetTextureColorMod(converter->arrow.texture, 255, 255, 255);
-    }
-    
-    SDL_RenderCopy(gs->renderer, converter->arrow.texture, NULL, &arrow_dst);
-
-    SDL_Surface **surf = &gs->surfaces.converter_names[converter->type];
-    SDL_Texture **tex = &gs->textures.converter_names[converter->type];
-    
-    if (!*surf) {
-        *surf = TTF_RenderText_Blended(gs->fonts.font_courier, converter->name, (SDL_Color){0, 0, 0, 255});
-    }
-    Assert(*surf);
-
-    if (!*tex) {
-        *tex = SDL_CreateTextureFromSurface(gs->renderer, *surf);
-    }
-    Assert(*tex);
-    
-    int margin = 8;
-    SDL_Rect r = {
-        (int) (converter->x + margin),
-        (int) (converter->y + margin + GUI_H),
-        (*surf)->w,
-        (*surf)->h
-    };
-    
-    SDL_RenderCopy(gs->renderer, *tex, NULL, &r);
-    
-    button_draw(converter->go_button);
-}
-
-void all_converters_draw() {
-    converter_draw(gs->material_converter);
-    converter_draw(gs->fuel_converter);
-    
-    if (gs->gui.popup && gs->gui.is_placer_active) {
-        placer_draw(converter_get_current_placer(), true);
-    }
-    
-    struct Input *input = &gs->input;
-    item_draw(&gs->item_holding, input->real_mx - ITEM_SIZE/2, input->real_my - ITEM_SIZE/2, ITEM_SIZE, ITEM_SIZE);
-}
+void converter_set_state(struct Converter *converter, enum Converter_State state) {
+    converter->state = state;
+    if (state == CONVERTER_OFF) {
+        converter->state = CONVERTER_OFF;
+        SDL_SetTextureColorMod(converter->arrow.texture, 255, 255, 255);
+    }
+}
+
+
+bool converter_is_layout_valid(struct Converter *converter) {
+    bool is_empty = true;
+    for (int i = 0; i < converter->slot_count; i++) {
+        if (converter->slots[i].item.type) {
+            is_empty = false;
+            break;
+        }
+    }
+    
+    if (is_empty) return false;
+    
+    return true;
+}
+
+void converter_begin_converting(void *converter_ptr) {
+    struct Converter *converter = (struct Converter *) converter_ptr;
+
+    if (!converter_is_layout_valid(converter))
+        return;
+
+    converter_set_state(converter, converter->state == CONVERTER_ON ? CONVERTER_OFF : CONVERTER_ON);
+}
+
+struct Placer *converter_get_current_placer() {
+    struct Placer *placers = gs->placers;
+    if (gs->current_placer == -1 || gs->current_tool != TOOL_PLACER) return NULL;
+    return &placers[gs->current_placer];
+}
+
+//////////////////////////////////////////
+
+struct Button *button_allocate(enum Button_Type type, SDL_Texture *texture, const char *tooltip_text, void (*on_pressed)(void*)) {
+    struct Button *b = arena_alloc(gs->persistent_memory, 1, sizeof(struct Button));
+    b->type = type;
+    b->texture = texture;
+    SDL_QueryTexture(texture, NULL, NULL, &b->w, &b->h);
+
+    strcpy(b->tooltip_text, tooltip_text);
+    b->on_pressed = on_pressed;
+    return b;
+}
+
+void click_gui_tool_button(void *type_ptr) {
+    int type = *((int*)type_ptr);
+    
+    struct GUI *gui = &gs->gui;
+
+    if (gui->popup) return;
+
+    gs->current_tool = type;
+    gs->chisel_blocker_mode = 0;
+    switch (gs->current_tool) {
+    case TOOL_CHISEL_SMALL:
+        gs->chisel = &gs->chisel_small;
+        for (int i = 0; i < gs->object_count; i++)
+            object_generate_blobs(i, 0);
+        gs->chisel_hammer.normal_dist = gs->chisel_hammer.dist = (f32) (gs->chisel->w+2);
+        break;
+    case TOOL_CHISEL_MEDIUM:
+        gs->chisel = &gs->chisel_medium;
+        for (int i = 0; i < gs->object_count; i++)
+            object_generate_blobs(i, 1);
+        gs->chisel_hammer.normal_dist = gs->chisel_hammer.dist = (f32) (gs->chisel->w+4);
+        break;
+    case TOOL_CHISEL_LARGE:
+        gs->current_tool = TOOL_CHISEL_LARGE;
+        gs->chisel = &gs->chisel_large;
+        for (int i = 0; i < gs->object_count; i++)
+            object_generate_blobs(i, 2);
+        gs->chisel_hammer.normal_dist = gs->chisel_hammer.dist = (f32) (gs->chisel->w+4);
+        break;
+    }
+
+    for (int i = 0; i < TOOL_COUNT; i++) {
+        gui->tool_buttons[i]->activated = 0;
+    }
+    tooltip_reset(&gui->tooltip);
+}
+
+void button_tick(struct Button *b, void *data) {
+    struct Input *input = &gs->input;
+    struct GUI *gui = &gs->gui;
+
+    int gui_input_mx = input->real_mx;
+    int gui_input_my = input->real_my;
+
+    // TODO: This is a temporary hack so that function pointers won't stop working
+    //       upon reloading the DLL.
+    switch (b->type) {
+    case BUTTON_TYPE_CONVERTER:
+        b->on_pressed = converter_begin_converting;
+        break;
+    case BUTTON_TYPE_TOOL_BAR:
+        b->on_pressed = click_gui_tool_button;
+        break;
+    }
+
+    if (gui_input_mx >= b->x && gui_input_mx < b->x+b->w &&
+        gui_input_my >= b->y && gui_input_my < b->y+b->h) {
+
+        tooltip_set_position_to_cursor(&gui->tooltip, TOOLTIP_TYPE_BUTTON);
+        b->just_had_tooltip = true;
+
+        if (strlen(b->tooltip_text))
+            strcpy(gui->tooltip.str[0], b->tooltip_text);
+
+        if (input->mouse_pressed[SDL_BUTTON_LEFT]) {
+            b->on_pressed(data);
+            b->activated = true;
+        }
+    } else if (b->just_had_tooltip) {
+        b->just_had_tooltip = false;
+        tooltip_reset(&gui->tooltip);
+    }
+
+    if (!(input->mouse & SDL_BUTTON(SDL_BUTTON_LEFT))) {
+        b->activated = false;
+    }
+}
+
+void button_draw(struct Button *b) {
+    struct Input *input = &gs->input;
+
+    int gui_input_mx = input->real_mx;// / gs->S;
+    int gui_input_my = input->real_my;// / gs->S;
+
+    SDL_Rect dst = {
+        b->x, b->y, b->w, b->h
+    };
+
+    if (b->activated) {
+        SDL_SetTextureColorMod(b->texture, 200, 200, 200);
+    } else if (gui_input_mx >= b->x && gui_input_mx < b->x+b->w &&
+               gui_input_my >= b->y && gui_input_my < b->y+b->h) {
+        SDL_SetTextureColorMod(b->texture, 230, 230, 230);
+    } else {
+        SDL_SetTextureColorMod(b->texture, 255, 255, 255);
+    }
+    SDL_RenderCopy(gs->renderer, b->texture, NULL, &dst);
+}
+
+void gui_message_stack_push(const char *str) {
+    struct GUI *gui = &gs->gui;
+
+    Assert(strlen(str) <= 100);
+    Assert(gui->message_count <= 32);
+
+    if (gui->message_count) {
+        for (int i = 0; i < gui->message_count; i++) {
+            gui->message_stack[i+1] = gui->message_stack[i];
+        }
+    }
+    gui->message_count++;
+    struct Message *msg = &gui->message_stack[0];
+
+    strcpy(msg->str, str);
+    msg->alpha = 255;
+}
+
+void gui_message_stack_tick_and_draw() {
+    struct GUI *gui = &gs->gui;
+
+    for (int i = 0; i < gui->message_count; i++) {
+        struct Message *msg = &gui->message_stack[i];
+    
+        SDL_Color col = { 255, 255, 255, msg->alpha };
+        draw_text(gs->fonts.font_consolas, msg->str, col, true, true, 0, GUI_H+gs->S*gs->gh - i*32, NULL, NULL);
+    
+        msg->alpha--;
+        if (msg->alpha == 127) {
+            gui->message_count--;
+            for (int j = i; j < gui->message_count; j++) {
+                gui->message_stack[j] = gui->message_stack[j+1];
+            }
+            i--;
+        }
+    }
+}
+
+void gui_init() {
+    struct GUI *gui = &gs->gui;
+
+    gui->popup_y = (f32) (gs->gh*gs->S);
+    gui->popup_y_vel = 0;
+    gui->popup_h = GUI_POPUP_H;
+    gui->popup = 0;
+    gui->popup_texture = gs->textures.popup;
+
+    tooltip_reset(&gui->tooltip);
+    gui->is_placer_active = false;
+
+    int cum = 0;
+
+    for (int i = 0; i < TOOL_COUNT; i++) {
+        char name[128] = {0};
+        get_name_from_tool(i, name);
+
+        if (gui->tool_buttons[i] == NULL) {
+            gui->tool_buttons[i] = button_allocate(BUTTON_TYPE_TOOL_BAR, gs->textures.tool_buttons[i], name, click_gui_tool_button);
+        }
+
+        gui->tool_buttons[i]->x = cum;
+        gui->tool_buttons[i]->y = 0;
+        gui->tool_buttons[i]->index = i;
+        gui->tool_buttons[i]->activated = i == gs->current_tool;
+
+        cum += gui->tool_buttons[i]->w;
+    }
+}
+
+void gui_tick() {
+    struct GUI *gui = &gs->gui;
+    struct Input *input = &gs->input;
+
+    if (input->keys_pressed[SDL_SCANCODE_TAB]) {
+        gui->popup = !gui->popup;
+        gui->popup_y_vel = 0;
+        tooltip_reset(&gui->tooltip);
+
+        gs->current_tool = gs->previous_tool;
+
+        // Just in case the player had reset it.
+        if (gs->current_placer == -1)
+            gs->current_placer = 0;
+    }
+
+    const f32 speed = 3.0f;
+
+    if (gui->popup) {
+        if (SDL_GetCursor() != gs->grabber_cursor) {
+            /* SDL_SetCursor(gs->grabber_cursor); */
+            /* SDL_ShowCursor(1); */
+        }
+
+        if (gui->popup_y > gs->S*gs->gh-gui->popup_h) {
+            gui->popup_y_vel -= speed;
+        } else {
+            gui->popup_y_vel = 0;
+            gui->popup_y = gs->S*gs->gh-gui->popup_h;
+        }
+
+        int was_placer_active = gui->is_placer_active;
+
+        gui->is_placer_active = input->keys[SDL_SCANCODE_LCTRL];
+
+        if (was_placer_active && !gui->is_placer_active) {
+            tooltip_reset(&gui->tooltip);
+        } else if (!was_placer_active && gui->is_placer_active) {
+            struct Placer *p = converter_get_current_placer();
+            p->x = input->mx;
+            p->y = input->my;
+        }
+    } else if (gui->popup_y < gs->S*gs->gh) {
+        gui->popup_y_vel += speed;
+    } else {
+        gui->popup_y = (f32) (gs->S*gs->gh);
+        gui->popup_y_vel = 0;
+    }
+
+    if (!gui->popup) {
+        /* SDL_SetCursor(normal_cursor); */
+        for (int i = 0; i < TOOL_COUNT; i++) {
+            button_tick(gui->tool_buttons[i], &i);
+        }
+        if (input->real_my >= GUI_H) {
+            // tooltip_reset(&gui->tooltip);
+        }
+    }
+
+    gui->popup_y += gui->popup_y_vel;
+    gui->popup_y = (f32) clamp((int) gui->popup_y, (int) (gs->S*gs->gh - gui->popup_h), gs->window_height);
+}
+
+void gui_draw() {
+    struct GUI *gui = &gs->gui;
+
+    // Draw the toolbar buttons.
+    SDL_Texture *old = SDL_GetRenderTarget(gs->renderer);
+
+    SDL_SetTextureBlendMode(RenderTarget(RENDER_TARGET_GUI_TOOLBAR), SDL_BLENDMODE_BLEND);
+
+    Assert(RenderTarget(RENDER_TARGET_GUI_TOOLBAR));
+    SDL_SetRenderTarget(gs->renderer, RenderTarget(RENDER_TARGET_GUI_TOOLBAR));
+
+    SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 0);
+    SDL_RenderClear(gs->renderer);
+
+    SDL_SetRenderDrawColor(gs->renderer, 64, 64, 64, 255);
+    SDL_Rect r = { 0, 0, gs->gw, GUI_H/gs->S };
+    SDL_RenderFillRect(gs->renderer, &r);
+
+    for (int i = 0; i < TOOL_COUNT; i++) {
+        button_draw(gui->tool_buttons[i]);
+    }
+
+    SDL_Rect dst = {
+        0, 0,
+        gs->gw*gs->S, GUI_H
+    };
+
+    SDL_SetRenderTarget(gs->renderer, NULL);
+    SDL_RenderCopy(gs->renderer, RenderTarget(RENDER_TARGET_GUI_TOOLBAR), NULL, &dst);
+    SDL_SetRenderTarget(gs->renderer, old);
+}
+
+void gui_popup_draw() {
+    struct GUI *gui = &gs->gui;
+
+    SDL_Rect popup = {
+        0, (int)(GUI_H + gui->popup_y),
+        gs->gw*gs->S, (int)gui->popup_h
+    };
+
+    SDL_SetRenderDrawColor(gs->renderer, 255, 255, 255, 255);
+    SDL_RenderFillRect(gs->renderer, &popup);
+}
+
+bool is_cell_fuel(int type) {
+    switch (type) {
+    case CELL_REFINED_COAL: case CELL_UNREFINED_COAL: case CELL_LAVA:
+        return true;
+    }
+    return false;
+}
+
+bool is_cell_stone(int type) {
+    switch (type) {
+    case CELL_COBBLESTONE: case CELL_MARBLE: case CELL_SANDSTONE:
+    case CELL_CONCRETE: case CELL_QUARTZ: case CELL_GRANITE:
+    case CELL_BASALT: case CELL_DIAMOND:
+        return true;
+    default:
+        return false;
+    }
+}
+
+// Possibilities:
+//   Tiers 1, 2, or 3.
+//   Returns 0 if no tier is specified.
+int get_cell_tier(int type) {
+    switch (type) {
+    case CELL_MARBLE: case CELL_COBBLESTONE: case CELL_SANDSTONE:
+        return 1;
+        break;
+    case CELL_CEMENT: case CELL_CONCRETE: case CELL_QUARTZ: case CELL_GLASS:
+        return 2;
+        break;
+    case CELL_GRANITE: case CELL_BASALT: case CELL_DIAMOND: // case CELL_GOLD:
+        return 3;
+        break;
+
+    case CELL_UNREFINED_COAL:
+        return 1;
+    case CELL_REFINED_COAL:
+        return 2;
+    case CELL_LAVA:
+        return 3;
+    }
+
+    return 0; // 0 = not specified in any tier.
+}
+
+bool can_place_item_in_slot(int type, int slot) {
+    bool can_put_fuel = false;
+    
+    if (slot == SLOT_FUEL) {
+        can_put_fuel = is_cell_fuel(type);
+    }
+    
+    return
+        slot == SLOT_INPUT1 ||
+        slot == SLOT_INPUT2 ||
+        can_put_fuel;
+}
+
+bool is_mouse_in_slot(struct Slot *slot) {
+    struct Input *input = &gs->input;
+    
+    return is_point_in_rect((SDL_Point){input->real_mx, input->real_my-GUI_H},
+                            (SDL_Rect){
+                                (int) (slot->converter->x + slot->x - slot->w/2),
+                                (int) (slot->converter->y + slot->y - slot->h/2),
+                                (int) slot->w,
+                                (int) slot->h
+                            });
+}
+
+bool was_mouse_in_slot(struct Slot *slot) {
+    struct Input *input = &gs->input;
+
+    return is_point_in_rect((SDL_Point){input->real_pmx,input->real_pmy-GUI_H},
+                            (SDL_Rect){
+                                (int) (slot->converter->x + slot->x - slot->w/2),
+                                (int) (slot->converter->y + slot->y - slot->h/2),
+                                (int) slot->w,
+                                (int) slot->h
+                            });
+}
+
+bool is_mouse_in_converter(struct Converter *converter) {
+    struct Input *input = &gs->input;
+    
+    return is_point_in_rect((SDL_Point){
+            input->real_mx,
+            input->real_my-GUI_H
+        },
+        (SDL_Rect){
+            (int)converter->x,
+            (int)converter->y,
+            (int)converter->w,
+            (int)converter->h
+        });
+}
+
+// Slot may be NULL if the item doesn't belong to any slot.
+// This function mostly just handles interactions with items and the mouse.
+void item_tick(struct Item *item, struct Slot *slot, int x, int y, int w, int h) {
+    struct Input *input = &gs->input;
+
+    if (item == &gs->item_holding) {
+        if (input->real_my < gs->gui.popup_y && input->mouse_pressed[SDL_BUTTON_LEFT]) {
+            // We pressed outside of the converter area.
+            // We will now kill the holding item.
+            gs->item_holding.type = 0;
+            gs->item_holding.amount = 0;
+        }
+        return;
+    }    
+
+    if (!is_point_in_rect((SDL_Point){input->real_mx, input->real_my-GUI_H}, (SDL_Rect){x, y, w, h})) return;
+    
+    // From this point onwards, we know the mouse is in this item,
+    // and this item is not currently being held.
+    
+    bool can_place_item = false;
+    
+    if (!gs->gui.is_placer_active) {
+        can_place_item = can_place_item_in_slot(gs->item_holding.type, slot->type);
+        if (!gs->item_holding.type) can_place_item = true;
+        
+        if (input->mouse_pressed[SDL_BUTTON_LEFT]) {
+            // If they're the same type, just add their amounts.
+            if (item->type && gs->item_holding.type == item->type) {
+                // Add the amount from holding to the item.
+                item->amount += gs->item_holding.amount;
+                
+                gs->item_holding.type = 0;
+                gs->item_holding.amount = 0;
+            }
+            
+            // Otherwise if we're either holding an item or have an item in slot,
+            // swap them since they're different types.
+            else if ((gs->item_holding.type || item->type) && can_place_item) {
+                struct Item a = *item;
+                
+                item->type = gs->item_holding.type;
+                item->amount = gs->item_holding.amount;
+                
+                gs->item_holding.type = a.type;
+                gs->item_holding.amount = a.amount;
+                
+                tooltip_reset(&gs->gui.tooltip);
+            } 
+            
+        } else if (input->mouse_pressed[SDL_BUTTON_RIGHT] && item->type && gs->item_holding.type == 0) { // If holding nothing
+            // Split the item into two like minecraft.
+            Assert(gs->item_holding.amount == 0);
+            
+            const int half = item->amount/2;
+            
+            if (half) {
+                item->amount -= half;
+                gs->item_holding.type = item->type;
+                gs->item_holding.amount += half;
+                
+                tooltip_reset(&gs->gui.tooltip);
+            }
+        }
+    } else if (gs->gui.is_placer_active) {
+        struct Placer *p = converter_get_current_placer();
+        struct Converter *converter = NULL;
+        
+        can_place_item = can_place_item_in_slot(p->contains_type, slot->type);
+        
+        if (is_mouse_in_converter(gs->material_converter)) {
+            converter = gs->material_converter;
+        } else if (is_mouse_in_converter(gs->fuel_converter)) {
+            converter = gs->fuel_converter;
+        }
+        
+        if (input->mouse_pressed[SDL_BUTTON_RIGHT]) {
+            if (p->contains_amount == 0) p->contains_type = 0;
+            if (p->contains_type == 0 || p->contains_type == item->type) {
+                p->contains_type = item->type;
+                p->contains_amount += item->amount;
+                
+                item->type = 0;
+                item->amount = 0;
+            }
+        } else if (can_place_item && input->mouse & SDL_BUTTON_LEFT) {
+            int amt = 0;
+            const int place_speed = 6;
+            
+            if (p->contains_amount && (!item->type || !item->amount)) {
+                item->type = p->contains_type;
+                amt = place_speed;
+            } else if (item->type == p->contains_type) {
+                amt = place_speed;
+            }
+            
+            if (p->contains_amount - converter->speed < 0) {
+                amt = p->contains_amount;
+            }
+            
+            item->amount += amt;
+            p->contains_amount -= amt;
+        }
+    }
+}
+
+void slot_tick(struct Slot *slot) {
+    item_tick(&slot->item,
+              slot,
+              (int) (slot->converter->x + slot->x - slot->w/2),
+              (int) (slot->converter->y + slot->y - slot->h/2),
+              (int) slot->w,
+              (int) slot->h);
+}
+
+void item_draw(struct Item *item, int x, int y, int w, int h) {
+    if (!item->type) return;
+    if (!item->amount) {
+        item->type = 0;
+        return;
+    }
+    
+    SDL_Rect r = {
+        x, y,
+        w, h
+
+    };
+    SDL_RenderCopy(gs->renderer, gs->textures.items[item->type], NULL, &r);
+    
+    char number[32] = {0};
+    sprintf(number, "%d", item->amount);
+    
+    SDL_Color color = (SDL_Color){255, 255, 255, 255};
+    
+    SDL_Surface *surf = TTF_RenderText_Solid(gs->fonts.font_bold_small, number, color);
+    SDL_Texture *texture = SDL_CreateTextureFromSurface(gs->renderer, surf);
+    
+    SDL_Rect dst = {
+        x + w - surf->w - 1,
+        y + h - surf->h - 1,
+        surf->w,
+        surf->h
+    };
+    
+    SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 255);
+    SDL_RenderFillRect(gs->renderer, &dst);
+    
+    SDL_RenderCopy(gs->renderer, texture, NULL, &dst);
+
+    SDL_FreeSurface(surf);
+    SDL_DestroyTexture(texture);
+}
+
+void slot_draw(struct Slot *slot) {
+    struct Converter *c = slot->converter;
+    SDL_Rect bounds = {
+        (int) (c->x + slot->x - slot->w/2),
+        (int) (c->y + slot->y - slot->h/2 + GUI_H),
+        (int) slot->w,
+        (int) slot->h
+    };
+    
+    int col = 200;
+    SDL_SetRenderDrawColor(gs->renderer, col, col, col, 255);
+    SDL_RenderFillRect(gs->renderer, &bounds);
+    
+    col = 0;
+    SDL_SetRenderDrawColor(gs->renderer, col, col, col, 255);
+    
+    bounds.x--;
+    bounds.y--;
+    bounds.w += 2;
+    bounds.h += 2;
+    
+    SDL_RenderDrawRect(gs->renderer, &bounds);
+    
+    bounds.x++;
+    bounds.y++;
+    bounds.w -= 2;
+    bounds.h -= 2;
+    
+    if (*slot->name) {
+        SDL_Surface **surf = &gs->surfaces.slot_names[SLOT_MAX_COUNT * c->type + slot->type];
+        SDL_Texture **texture = &gs->textures.slot_names[SLOT_MAX_COUNT * c->type + slot->type];
+        
+        if (!*surf) {
+            *surf = TTF_RenderText_Blended(gs->fonts.font_small, slot->name, (SDL_Color){0, 0, 0, 255});
+        }
+        Assert(*surf);
+
+        if (!*texture) {
+            *texture = SDL_CreateTextureFromSurface(gs->renderer, *surf);
+        }
+
+        Assert(*texture);
+        
+        SDL_Rect dst = {
+            (int) (bounds.x + slot->w/2 - (*surf)->w/2),
+            (int) (bounds.y - (*surf)->h - 2),
+            (*surf)->w,
+            (*surf)->h
+        };
+        SDL_RenderCopy(gs->renderer, *texture, NULL, &dst);
+    }
+    
+    item_draw(&slot->item, bounds.x, bounds.y, bounds.w, bounds.h);
+}
+
+//////////////////////////////////////////
+
+struct Converter *converter_init(int type, bool allocated) {
+    struct Converter *converter = NULL;
+
+    if (!allocated) {
+        converter = arena_alloc(gs->persistent_memory, 1, sizeof(struct Converter));
+    } else {
+        switch (type) {
+        case CONVERTER_FUEL:
+            converter = gs->fuel_converter;
+            break;
+        case CONVERTER_MATERIAL:
+            converter = gs->material_converter;
+            break;
+        }
+    }
+    
+    converter->type = type;
+    converter->w = (f32) (gs->window_width/2);
+    converter->h = GUI_POPUP_H;
+    
+    converter->timer_max = 1;
+    converter->timer_current = 0;
+    
+    switch (type) {
+    case CONVERTER_MATERIAL:
+        converter->slot_count = 4;
+
+        if (!allocated) {
+            converter->slots = arena_alloc(gs->persistent_memory, converter->slot_count, sizeof(struct Slot));
+        }
+        
+        converter->slots[SLOT_INPUT1].x = converter->w/3.f;
+        converter->slots[SLOT_INPUT1].y = converter->h/4.f;
+        strcpy(converter->slots[SLOT_INPUT1].name, "Inp. 1");
+        
+        converter->slots[SLOT_INPUT2].x = 2.f*converter->w/3.f;
+        converter->slots[SLOT_INPUT2].y = converter->h/4.f;
+        strcpy(converter->slots[SLOT_INPUT2].name, "Inp. 2");
+        
+        converter->slots[SLOT_FUEL].x = 3.f*converter->w/4.f;
+        converter->slots[SLOT_FUEL].y = converter->h/2.f;
+        strcpy(converter->slots[SLOT_FUEL].name, "Fuel");
+        
+        converter->slots[SLOT_OUTPUT].x = converter->w/2.f;
+        converter->slots[SLOT_OUTPUT].y = 4.f*converter->h/5.f;
+        strcpy(converter->slots[SLOT_OUTPUT].name, "Output");
+        
+        strcpy(converter->name, "Material Converter");
+        break;
+    case CONVERTER_FUEL:
+        converter->slot_count = 3;
+
+        if (!allocated) {
+            converter->slots = arena_alloc(gs->persistent_memory, converter->slot_count, sizeof(struct Slot));
+        }
+        
+        converter->slots[SLOT_INPUT1].x = converter->w/3.f;
+        converter->slots[SLOT_INPUT1].y = converter->h/4.f;
+        strcpy(converter->slots[SLOT_INPUT1].name, "Inp. 1");
+        
+        converter->slots[SLOT_INPUT2].x = 2.f*converter->w/3.f;
+        converter->slots[SLOT_INPUT2].y = converter->h/4.f;
+        strcpy(converter->slots[SLOT_INPUT2].name, "Inp. 2");
+        
+        converter->slots[SLOT_OUTPUT].x = converter->w/2.f;
+        converter->slots[SLOT_OUTPUT].y = 4.f*converter->h/5.f;
+        strcpy(converter->slots[SLOT_OUTPUT].name, "Output");
+        
+        strcpy(converter->name, "Fuel Converter");
+        break;
+    }
+    
+    // Indices line up with Slot_Type enum
+    // even though slot_count is variable.
+    for (int i = 0; i < converter->slot_count; i++) {
+        converter->slots[i].type = i;
+        converter->slots[i].w = ITEM_SIZE;
+        converter->slots[i].h = ITEM_SIZE;
+        converter->slots[i].converter = converter;
+    }
+    
+    converter->arrow.texture = gs->textures.converter_arrow;
+    SDL_QueryTexture(converter->arrow.texture, NULL, NULL, &converter->arrow.w, &converter->arrow.h);
+    
+    converter->arrow.x = (int) (converter->w/2);
+    converter->arrow.y = (int) (converter->h/2 + 24);
+    converter->speed = 8;
+    
+    // Both X and Y-coordinates are updated in converter_tick.
+    if (converter->go_button == NULL) {
+        converter->go_button = button_allocate(BUTTON_TYPE_CONVERTER, gs->textures.convert_button, "Convert", converter_begin_converting);
+    }
+    converter->go_button->w = 48;
+    converter->go_button->h = 48;
+    
+    return converter;
+}
+
+void all_converters_init() {
+    bool allocated = gs->material_converter != NULL || gs->fuel_converter != NULL;
+    gs->material_converter = converter_init(CONVERTER_MATERIAL, allocated);
+    gs->fuel_converter = converter_init(CONVERTER_FUEL, allocated);
+}
+
+int get_number_unique_inputs(struct Item *input1, struct Item *input2) {
+    int number_inputs = (input1->type != 0) + (input2->type != 0);
+    int number_unique_inputs = 0;
+
+    if (number_inputs == 1) {
+        number_unique_inputs = 1;
+    } else if (number_inputs == 2) {
+        if (input1->type != input2->type) {
+            number_unique_inputs = 2;
+        } else {
+            number_unique_inputs = 1;
+        }
+    }
+
+    return number_unique_inputs;
+}
+
+struct Converter_Checker converter_checker(struct Item *input1, struct Item *input2) {
+    Assert(input1);
+    Assert(input2);
+
+    return (struct Converter_Checker) {
+        input1, input2, 0
+    };
+}
+
+bool is_either_input_type(struct Converter_Checker *checker, int type, bool restart) {
+    Assert(checker->input1);
+    Assert(checker->input2);
+
+    if (restart) {
+        checker->current = 0;
+    }
+
+    if (checker->current == 0) {
+        if (checker->input1->type == type) {
+            checker->current = 2;
+        } else if (checker->input2->type == type) {
+            checker->current = 1;
+        } else {
+            return false;
+        }
+    } else {
+        if ((checker->current == 2 && checker->input2->type != type) ||
+            (checker->current == 1 && checker->input1->type != type)) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool is_either_input_tier(struct Converter_Checker *checker, int tier, bool is_fuel, bool restart) {
+    Assert(checker->input1);
+    Assert(checker->input2);
+
+    if (restart) {
+        checker->current = 0;
+    }
+
+    if (checker->current == 0) {
+        if (get_cell_tier(checker->input1->type) == tier) {
+            checker->current = 2;
+        } else if (get_cell_tier(checker->input2->type) == tier) {
+            checker->current = 1;
+        }
+    } else {
+        if (is_fuel) {
+            return ((checker->current == 2 && is_cell_fuel(checker->input2->type) && tier == get_cell_tier(checker->input2->type)) ||
+                    (checker->current == 1 && is_cell_fuel(checker->input1->type) && tier == get_cell_tier(checker->input1->type)));
+        } else {
+            return ((checker->current == 2 && !is_cell_fuel(checker->input2->type) && tier == get_cell_tier(checker->input2->type)) ||
+                    (checker->current == 1 && !is_cell_fuel(checker->input1->type) && tier == get_cell_tier(checker->input1->type)));
+        }
+    }
+
+    return true;
+}
+
+bool is_either_input_stone(struct Converter_Checker *checker, bool restart) {
+    Assert(checker->input1);
+    Assert(checker->input2);
+
+    if (restart) {
+        checker->current = 0;
+    }
+
+    if (checker->current == 0) {
+        if (is_cell_stone(checker->input1->type)) {
+            checker->current = 2;
+        } else if (is_cell_stone(checker->input2->type)) {
+            checker->current = 1;
+        }
+    } else {
+        if ((checker->current == 2 && !is_cell_stone(checker->input2->type)) ||
+            (checker->current == 1 && !is_cell_stone(checker->input1->type))) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+// Calculate the ratio of inputs -> output.
+f32 calculate_output_ratio(struct Item *input1, struct Item *input2) {
+    f32 result = 0.f;
+    int number_unique_inputs = get_number_unique_inputs(input1, input2);
+
+    result = (f32) (number_unique_inputs * number_unique_inputs);
+
+    return result;
+}
+
+int fuel_converter_convert(struct Item *input1, struct Item *input2) {
+    int result_type = 0;
+    int number_inputs = (input1->type != 0) + (input2->type != 0);
+    int number_unique_inputs = 0;
+
+    struct Item *input = NULL;
+
+    if (number_inputs == 1) {
+        input = input1->type ? input1 : input2;
+    } else if (number_inputs == 2) {
+        input = input1;
+    }
+
+    number_unique_inputs = get_number_unique_inputs(input1, input2);
+
+    if (number_unique_inputs == 1) {
+        if (input->type == CELL_DIRT ||
+            input->type == CELL_SAND ||
+            !is_cell_fuel(input->type) && get_cell_tier(input->type) == 1)
+        {
+            result_type = CELL_UNREFINED_COAL;
+        }
+    }
+    else if (number_unique_inputs == 2) {
+        struct Converter_Checker checker = converter_checker(input1, input2);
+
+        if (is_either_input_type(&checker, CELL_UNREFINED_COAL, false) &&
+            is_either_input_tier(&checker, 2, false, false))
+        {
+            result_type = CELL_REFINED_COAL;
+        }
+
+        else if (is_either_input_type(&checker, CELL_UNREFINED_COAL, true) &&
+                 is_either_input_type(&checker, CELL_LAVA, false))
+        {
+            result_type = CELL_REFINED_COAL; // TODO: Higher output ratio.
+        }
+
+        else if (is_either_input_type(&checker, CELL_REFINED_COAL, true) &&
+                 is_either_input_stone(&checker, false))
+        {
+            result_type = CELL_LAVA;
+        }
+    }
+
+    return result_type;
+}
+
+int material_converter_convert(struct Item *input1, struct Item *input2, struct Item *fuel) {
+    Assert(input1);
+    Assert(input2);
+
+    int result_type = 0;
+    int number_inputs = (input1->type != 0) + (input2->type != 0);
+
+    // TOOD: Turn this into number_unique_inputs? Won't this not work
+    //       with that?
+
+    struct Item *input = NULL;
+
+    if (number_inputs == 1) {
+        input = input1->type ? input1 : input2;
+    } else if (number_inputs == 2) {
+        input = input1;
+    }
+    
+    switch (fuel->type) {
+    case CELL_NONE:
+        switch (input->type) {
+        case CELL_WOOD_LOG:
+            result_type = CELL_WOOD_PLANK;
+            break;
+        }
+        break;
+    case CELL_UNREFINED_COAL:
+        if (number_inputs == 2) {
+            struct Converter_Checker checker = converter_checker(input1, input2);
+
+            if (is_either_input_type(&checker, CELL_COBBLESTONE, true) &&
+                is_either_input_type(&checker, CELL_SAND, false))
+            {
+                result_type = CELL_SANDSTONE;
+            }
+        } else if (number_inputs == 1) {
+            switch (input->type) {
+            case CELL_SAND:
+                result_type = CELL_GLASS;
+                break;
+            case CELL_DIRT:
+                result_type = CELL_COBBLESTONE;
+                break;
+            case CELL_COBBLESTONE:
+                result_type = CELL_MARBLE;
+                break;
+            case CELL_ICE:
+                result_type = CELL_WATER;
+                break;
+            case CELL_WATER:
+                result_type = CELL_STEAM;
+                break;
+            }
+        }
+        break;
+    case CELL_REFINED_COAL:
+        if (number_inputs == 1) {
+            switch (input->type) {
+            case CELL_DIRT:
+                result_type = CELL_COBBLESTONE;
+                break;
+            case CELL_ICE:
+                result_type = CELL_STEAM;
+                break;
+            }
+        } else if (number_inputs == 2) {
+            struct Converter_Checker checker = converter_checker(input1, input2);
+
+            if (is_either_input_type(&checker, CELL_SANDSTONE, true) &&
+                is_either_input_type(&checker, CELL_MARBLE, false))
+            {
+                result_type = CELL_QUARTZ;
+            }
+            else if (is_either_input_type(&checker, CELL_WATER, true) &&
+                     is_either_input_type(&checker, CELL_COBBLESTONE, false))
+            {
+                result_type = CELL_CEMENT;
+            }
+        }
+
+        break;
+    case CELL_LAVA:
+        if (number_inputs == 1) {
+            switch (input->type) {
+            case CELL_REFINED_COAL: case CELL_UNREFINED_COAL:
+                result_type = CELL_BASALT;
+                break;
+            }
+        } else if (number_inputs == 2) {
+            struct Converter_Checker checker = converter_checker(input1, input2);
+
+            if (is_either_input_type(&checker, CELL_QUARTZ, true) &&
+                is_either_input_type(&checker, CELL_MARBLE, false))
+            {
+                result_type = CELL_GRANITE;
+            }
+            else if (is_either_input_type(&checker, CELL_BASALT, true) &&
+                     is_either_input_type(&checker, CELL_GRANITE, false))
+            {
+                result_type = CELL_DIAMOND;
+            }
+        }
+        break;
+    }
+    
+    return result_type;
+}
+
+// Returns if the conversion went succesfully.
+bool converter_convert(struct Converter *converter) {
+    bool did_convert = false;
+
+    int temp_output_type = 0;
+
+    struct Item *input1 = &converter->slots[SLOT_INPUT1].item;
+    struct Item *input2 = &converter->slots[SLOT_INPUT2].item;
+    struct Item *output = &converter->slots[SLOT_OUTPUT].item;
+    struct Item *fuel = NULL;
+
+    if (converter->type == CONVERTER_MATERIAL) {
+        fuel = &converter->slots[SLOT_FUEL].item;
+    }
+
+    int number_inputs = (input1->type != 0) + (input2->type != 0);
+
+    if (!number_inputs) return false;
+    /* if (fuel && (!fuel->type || fuel->amount == 0)) return false; */
+
+    if (converter->type == CONVERTER_FUEL) {
+        temp_output_type = fuel_converter_convert(input1, input2);
+    } else if (converter->type == CONVERTER_MATERIAL) {
+        temp_output_type = material_converter_convert(input1, input2, fuel);
+    }
+
+    if (!temp_output_type) return false;
+
+    f32 output_ratio = calculate_output_ratio(input1, input2);
+
+    bool final_conversion = false;
+
+    // Actually remove amounts from the inputs and increase
+    // or set the output.
+    if (temp_output_type == output->type || output->type == 0) {
+        output->type = temp_output_type;
+
+        int amount = (int) (converter->speed * output_ratio);
+
+        // Check if any input, when reduced by the amount,
+        // gives negative amount. If so, lock the amount
+        // we're reducing to by the correct amount.
+        if (input1->type && input1->amount-amount < 0) {
+            amount = input1->amount;
+            final_conversion = true;
+        }
+        if (input2->type && input2->amount-amount < 0) {
+            amount = input2->amount;
+            final_conversion = true;
+        }
+
+        // The same for fuel, but make sure to multiple by the
+        // number of inputs to compensate otherwise you'd be able
+        // to use half the amount of fuel for the same output if
+        // you just split the input in two.
+        if (fuel && fuel->type && fuel->amount-amount < 0) {
+            amount = fuel->amount * number_inputs; // *ing to compensate.
+            final_conversion = true;
+        }
+
+        int amount_add = 0;
+        if (input1->type) {
+            input1->amount -= amount;
+            amount_add += amount;
+        }
+        if (input2->type) {
+            input2->amount -= amount;
+            amount_add += amount;
+        }
+
+        if (fuel && fuel->type)
+            fuel->amount -= amount_add;
+        output->amount += amount_add;
+
+        did_convert = true;
+    }
+
+    return !final_conversion || !did_convert;
+}
+
+void converter_tick(struct Converter *converter) {
+    converter->arrow.y = (int) (converter->h/2 + 18);
+    
+    switch (converter->type) {
+    case CONVERTER_MATERIAL:
+        converter->x = 0;
+        converter->y = gs->gui.popup_y;
+        break;
+    case CONVERTER_FUEL:
+        converter->x = (f32) (gs->S*gs->gw/2);
+        converter->y = (f32) (gs->gui.popup_y);
+        break;
+    }
+    
+    converter->go_button->x = (int) (converter->x + converter->arrow.x - 128);
+    converter->go_button->y = (int) (gs->gui.popup_y + 240);
+    
+    for (int i = 0; i < converter->slot_count; i++) {
+        struct Slot *s = &converter->slots[i];
+        slot_tick(s);
+    }
+    
+    button_tick(converter->go_button, converter);
+    
+    if (converter->state == CONVERTER_ON) {
+        if (converter->timer_current < converter->timer_max) {
+            converter->timer_current += 1;
+        } else {
+            converter->timer_current = 0;
+            switch (converter->type) {
+            case CONVERTER_MATERIAL: {
+                bool did_convert = converter_convert(gs->material_converter);
+                if (!did_convert) {
+                    converter_set_state(gs->material_converter, CONVERTER_OFF);
+                }
+                break;
+            }
+            case CONVERTER_FUEL: {
+                bool did_convert = converter_convert(gs->fuel_converter);
+                if (!did_convert) {
+                    converter_set_state(gs->fuel_converter, CONVERTER_OFF);
+                }
+                break;
+            }
+            }
+        }
+    }
+    
+    if (!gs->gui.popup) return;
+}
+
+void all_converters_tick() {
+    if (gs->gui.popup && gs->current_tool != TOOL_PLACER) {
+        gs->previous_tool = gs->current_tool;
+        gs->current_tool = TOOL_PLACER;
+    }
+    
+    if (gs->gui.popup && gs->gui.is_placer_active) {
+        placer_tick(converter_get_current_placer());
+    }
+    
+    converter_tick(gs->material_converter);
+    converter_tick(gs->fuel_converter);
+    
+    if (!gs->gui.is_placer_active) {
+        bool set_tooltip_this_frame = false;
+        
+        for (int i = 0; i < 2; i++) {
+            struct Converter *c = i == 0 ? gs->material_converter : gs->fuel_converter;
+            
+            for (int j = 0; j < c->slot_count; j++) {
+                if (!c->slots[j].item.type) continue;
+                
+                if (is_mouse_in_slot(&c->slots[j])) {
+                    tooltip_set_position_to_cursor(&gs->gui.tooltip, TOOLTIP_TYPE_ITEM);
+                    
+                    char type[64] = {0};
+                    char type_name[64] = {0};
+                    char amount[64] = {0};
+                    
+                    get_name_from_type(c->slots[j].item.type, type_name);
+                    sprintf(type, "Type: %s", type_name);
+                    sprintf(amount, "Amount: %d", c->slots[j].item.amount);
+                    
+                    strcpy(gs->gui.tooltip.str[0], type);
+                    strcpy(gs->gui.tooltip.str[1], amount);
+                    
+                    set_tooltip_this_frame = true;
+                } else if (!set_tooltip_this_frame && gs->gui.tooltip.type == TOOLTIP_TYPE_ITEM) {
+                    tooltip_reset(&gs->gui.tooltip);
+                }
+            }
+        }
+    }
+    
+    struct Input *input = &gs->input;
+    item_tick(&gs->item_holding, NULL, input->real_mx, input->real_my, ITEM_SIZE, ITEM_SIZE);
+}
+
+void converter_draw(struct Converter *converter) {
+    SDL_Rect converter_bounds = {
+        (int)converter->x, (int)converter->y + GUI_H,
+        (int)converter->w, (int)converter->h
+    };
+    
+    SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 255);
+    SDL_RenderDrawRect(gs->renderer, &converter_bounds);
+    
+    for (int i = 0; i < converter->slot_count; i++) {
+        slot_draw(&converter->slots[i]);
+    }
+    
+    SDL_Rect arrow_dst = {
+        (int) (converter->x + converter->arrow.x - converter->arrow.w / 2.0),
+        (int) (converter->y + converter->arrow.y + converter->arrow.h / 2.0),
+        converter->arrow.w,
+        converter->arrow.h
+    };
+    
+    // Flashing the arrow itself.
+    if (converter->state == CONVERTER_ON) {
+        const int period = 500; // Milliseconds.
+        Uint8 a = (SDL_GetTicks()/period) % 2 == 0;
+        a = a ? 255 : 190;
+
+        SDL_SetTextureColorMod(converter->arrow.texture, a, a, a);
+    }
+    // Since we use the same texture for both converters,
+    // we need to reset it every time as well.
+    else {
+        SDL_SetTextureColorMod(converter->arrow.texture, 255, 255, 255);
+    }
+    
+    SDL_RenderCopy(gs->renderer, converter->arrow.texture, NULL, &arrow_dst);
+
+    SDL_Surface **surf = &gs->surfaces.converter_names[converter->type];
+    SDL_Texture **tex = &gs->textures.converter_names[converter->type];
+    
+    if (!*surf) {
+        *surf = TTF_RenderText_Blended(gs->fonts.font_courier, converter->name, (SDL_Color){0, 0, 0, 255});
+    }
+    Assert(*surf);
+
+    if (!*tex) {
+        *tex = SDL_CreateTextureFromSurface(gs->renderer, *surf);
+    }
+    Assert(*tex);
+    
+    int margin = 8;
+    SDL_Rect r = {
+        (int) (converter->x + margin),
+        (int) (converter->y + margin + GUI_H),
+        (*surf)->w,
+        (*surf)->h
+    };
+    
+    SDL_RenderCopy(gs->renderer, *tex, NULL, &r);
+    
+    button_draw(converter->go_button);
+}
+
+void all_converters_draw() {
+    converter_draw(gs->material_converter);
+    converter_draw(gs->fuel_converter);
+    
+    if (gs->gui.popup && gs->gui.is_placer_active) {
+        placer_draw(converter_get_current_placer(), true);
+    }
+    
+    struct Input *input = &gs->input;
+    item_draw(&gs->item_holding, input->real_mx - ITEM_SIZE/2, input->real_my - ITEM_SIZE/2, ITEM_SIZE, ITEM_SIZE);
+}
diff --git a/src/gui.h b/src/gui.h
index abcf65e..05267b1 100644
--- a/src/gui.h
+++ b/src/gui.h
@@ -1,3 +1,5 @@
+#pragma once
+
 #define MAX_TOOLTIP_LEN 128
 #define MAX_TOOLTIP_LINE_LEN 128
 #define CONVERTER_NAME_LEN 32
@@ -27,6 +29,11 @@ struct Tooltip {
     int w, h;
 };
 
+struct Message {
+    char str[100];
+    Uint8 alpha;
+};
+
 struct GUI {
     int popup;
     bool is_placer_active;
@@ -35,6 +42,9 @@ struct GUI {
     struct Tooltip tooltip;
 
     struct Button *tool_buttons[TOOL_COUNT];
+
+    struct Message message_stack[32];
+    int message_count;
 };
 
 struct Button {
@@ -72,7 +82,7 @@ struct Slot {
     char name[32];
     int dx, dy;                  // Orientation of the name string.
 
-    f32 x, y, w, h;            // Relative to the converter it's in.
+    f32 x, y, w, h;              // Relative to the converter it's in.
 };
 
 enum Converter_Type {
diff --git a/src/input.c b/src/input.c
index 4d27ba9..3a708d7 100644
--- a/src/input.c
+++ b/src/input.c
@@ -7,8 +7,8 @@ void input_tick(struct Game_State *state) {
     in->real_pmx = in->real_mx;
     in->real_pmy = in->real_my;
 
-    persist Uint8 keys_previous[SDL_NUM_SCANCODES] = {0};
-    persist Uint32 mouse_previous = {0};
+    static Uint8 keys_previous[SDL_NUM_SCANCODES] = {0};
+    static Uint32 mouse_previous = {0};
 
     in->mouse = (Uint32) SDL_GetMouseState(&in->real_mx, &in->real_my);
     in->keys = (Uint8*) SDL_GetKeyboardState(NULL);
diff --git a/src/knife.c b/src/knife.c
deleted file mode 100644
index 63ec6fc..0000000
--- a/src/knife.c
+++ /dev/null
@@ -1,97 +0,0 @@
-void knife_init() {
-    struct Knife *knife = &gs->knife;
-
-    knife->x = gs->gw/2.f;
-    knife->y = gs->gh/2.f;
-
-    knife->texture = gs->textures.knife;
-    SDL_QueryTexture(knife->texture, NULL, NULL, &knife->w, &knife->h);
-    
-    knife->angle = 0;
-
-    if (knife->pixels == NULL) {
-        knife->pixels = arena_alloc(gs->persistent_memory, gs->gw*gs->gh, sizeof(Uint32));
-    }
-}
-
-void knife_update_texture() {
-    struct Knife *knife = &gs->knife;
-
-    SDL_Texture *prev_target = SDL_GetRenderTarget(gs->renderer);
-    SDL_SetTextureBlendMode(RenderTarget(RENDER_TARGET_KNIFE), SDL_BLENDMODE_BLEND);
-    
-    Assert(RenderTarget(RENDER_TARGET_KNIFE));
-    SDL_SetRenderTarget(gs->renderer, RenderTarget(RENDER_TARGET_KNIFE));
-
-    SDL_SetRenderDrawColor(gs->renderer, 0, 0, 0, 0);
-    SDL_RenderClear(gs->renderer);
-    
-    SDL_SetRenderDrawColor(gs->renderer, 255, 255, 255, 255);
-    
-    const SDL_Rect dst = {
-        (int) knife->x, (int) (knife->y - knife->h/2),
-        knife->w, knife->h
-    };
-    const SDL_Point center = { 0, knife->h/2 };
-
-    SDL_RenderCopyEx(gs->renderer, knife->texture, NULL, &dst, knife->angle, &center, SDL_FLIP_NONE);
-
-    SDL_RenderReadPixels(gs->renderer, NULL, 0, knife->pixels, 4*gs->gw);
-
-    SDL_SetRenderTarget(gs->renderer, prev_target);
-}
-
-void knife_draw() {
-    knife_update_texture();
-    SDL_RenderCopy(gs->renderer, RenderTarget(RENDER_TARGET_KNIFE), NULL, NULL);
-}
-
-void knife_tick() {
-    struct Knife *knife = &gs->knife;
-    struct Input *input = &gs->input;
-
-    f32 px = knife->x;
-    f32 py = knife->y;
-    
-    if (input->keys[SDL_SCANCODE_LCTRL]) {
-        knife->angle = 180.f + 360.f * atan2f(input->my - knife->y, input->mx - knife->x) / (2.f*(f32)M_PI);
-        /* SDL_ShowCursor(1); */
-    } else if (input->keys_released[SDL_SCANCODE_LCTRL]) {
-        move_mouse_to_grid_position(knife->x, knife->y);
-        input->mx = (int)knife->x;
-        input->my = (int)knife->y;
-        /* SDL_ShowCursor(0); */
-    }
-
-    if (!input->keys[SDL_SCANCODE_LCTRL]) {
-        knife->x = (f32) input->mx;
-        knife->y = (f32) input->my;
-    }
-
-    if (input->mouse & SDL_BUTTON(SDL_BUTTON_LEFT)) {
-        f32 dx = knife->x - px;
-        f32 dy = knife->y - py;
-        f32 len = sqrtf(dx*dx + dy*dy);
-        f32 ux = dx/len;
-        f32 uy = dy/len;
-
-        knife->x = px;
-        knife->y = py;
-
-        while (sqrt((knife->x-px)*(knife->x-px) + (knife->y-py)*(knife->y-py)) < len) {
-            for (int y = (int) (knife->y-knife->h/2); y < (int)(knife->y+knife->h/2); y++) {
-                for (int x = (int) (knife->x-knife->h/2); x < (int)(knife->x+knife->h/2); x++) {
-                    if (is_in_bounds(x, y)) continue;
-                    if (knife->pixels[x+y*gs->gw] == 0xFFFFFF && gs->grid[x+y*gs->gw].type) {
-                        gs->grid[x+y*gs->gw].depth = 256-64;
-                    }
-                }
-            }
-            knife->x += ux;
-            knife->y += uy;
-            knife_update_texture();
-        }
-        knife->x = (f32)knife->x;
-        knife->y = (f32)knife->y;
-    }
-}
diff --git a/src/knife.h b/src/knife.h
deleted file mode 100644
index 702ff2b..0000000
--- a/src/knife.h
+++ /dev/null
@@ -1,7 +0,0 @@
-struct Knife {
-    f32 x, y;
-    int w, h;
-    f32 angle;
-    SDL_Texture *texture;
-    Uint32 *pixels;
-};
diff --git a/src/level.c b/src/level.c
index 4630671..3b6fe13 100644
--- a/src/level.c
+++ b/src/level.c
@@ -185,9 +185,7 @@ void goto_level(int lvl) {
     
     chisel_blocker_init();
     blocker_init();
-    blob_hammer_init();
     chisel_hammer_init();
-    knife_init();
     deleter_init();
     for (int i = 0; i < PLACER_COUNT; i++)
         placer_init(i);
@@ -288,27 +286,22 @@ void level_tick() {
          *     SDL_SetCursor(gs->normal_cursor);
          * } */
     
-        overlay_tick();
         chisel_blocker_tick();
         blocker_tick();
 
         if (gs->chisel_blocker_mode) break;
         if (gs->blocker.state) break;
-        if (gs->overlay.tool) break;
         
         switch (gs->current_tool) {
         case TOOL_CHISEL_SMALL: case TOOL_CHISEL_MEDIUM: case TOOL_CHISEL_LARGE:
             chisel_tick();
             break;
-        case TOOL_KNIFE:
-            knife_tick();
+        case TOOL_OVERLAY:
+            overlay_tick();
             break;
         case TOOL_DELETER:
             deleter_tick();
             break;
-        case TOOL_HAMMER:
-            blob_hammer_tick();
-            break;
         case TOOL_PLACER:
             if (!gs->gui.popup) // We'll handle updating it in the converter
                 placer_tick(&gs->placers[gs->current_placer]);
@@ -385,15 +378,9 @@ void level_draw() {
         case TOOL_CHISEL_SMALL: case TOOL_CHISEL_MEDIUM: case TOOL_CHISEL_LARGE:
             chisel_draw();
             break;
-        case TOOL_KNIFE:
-            knife_draw();
-            break;
         case TOOL_DELETER:
             deleter_draw();
             break;
-        case TOOL_HAMMER:
-            blob_hammer_draw();
-            break;
         case TOOL_PLACER:
             if (!gs->gui.popup) // When gui.popup = true, we draw in converter
                 placer_draw(&gs->placers[gs->current_placer], false);
diff --git a/src/main.c b/src/main.c
index 306bfcd..8eb309b 100644
--- a/src/main.c
+++ b/src/main.c
@@ -42,6 +42,7 @@
 
 // Include all files to compile in one translation unit for
 // compilation speed's sake. ("Unity Build")
+#include "util.c"
 #include "assets.c"
 #include "input.c"
 
@@ -81,20 +82,20 @@ void game_init_sdl(struct Game_State *state, const char *window_title, int w, in
 void make_memory(struct Memory *persistent_memory, struct Memory *transient_memory) {
     persistent_memory->size = Megabytes(512);
     transient_memory->size = Megabytes(32);
-
+    
     AssertNW(persistent_memory->size >= sizeof(struct Game_State));
-
+    
     LPVOID base_address = (LPVOID) Terabytes(2);
-
+    
     printf("Large Page Size: %llu\n", GetLargePageMinimum());
-
+    
     persistent_memory->data = VirtualAlloc(base_address,
                                            persistent_memory->size + transient_memory->size,
                                            MEM_COMMIT|MEM_RESERVE,
                                            PAGE_READWRITE);
     AssertNW(persistent_memory->data);
     persistent_memory->cursor = persistent_memory->data;
-
+    
     // Set the transient memory as an offset into persistent memory.
     transient_memory->data = persistent_memory->data + persistent_memory->size;
     transient_memory->cursor = transient_memory->data;
@@ -106,10 +107,10 @@ void game_init(struct Game_State *state) {
     state->S = 6;
     state->window_width = 128*state->S;
     state->window_height = 128*state->S + GUI_H;
-
+    
     // Taken from https://github.com/kumar8600/win32_SetProcessDpiAware
     win32_SetProcessDpiAware();
-
+    
     game_init_sdl(state, "Alaska", state->window_width, state->window_height);
     
     // Load all assets... except for render targets.
@@ -130,7 +131,7 @@ void game_init(struct Game_State *state) {
 void game_deinit(struct Game_State *state) {
     // Close the window first so it'll feel snappy.
     SDL_DestroyWindow(state->window);
-
+    
     textures_deinit(&state->textures);
     surfaces_deinit(&state->surfaces);
     fonts_deinit(&state->fonts);
@@ -165,11 +166,11 @@ void load_game_code(struct Game_Code *code) {
         fprintf(stderr, "Error loading the DLL!\n");
         exit(1);
     }
-
+    
     code->game_init = (GameInitProc) GetProcAddress(code->dll, "game_init");
     code->game_tick_event = (GameTickEventProc) GetProcAddress(code->dll, "game_tick_event");
     code->game_run = (GameRunProc) GetProcAddress(code->dll, "game_run");
-
+    
     if (!code->game_run) {
         fprintf(stderr, "Error finding the functions in the DLL!\n");
         exit(1);
@@ -190,59 +191,59 @@ int main(int argc, char **argv) {
         char cwd[1024] = {0};
         size_t length = 0;
         char *final_three_chars = NULL;
-    
+        
         GetCurrentDirectory(1024, cwd);
         length = strlen(cwd);
-
+        
         final_three_chars = cwd+length-3;
-
+        
         AssertNW(0 == strcmp(final_three_chars, "bin"));
     }
-
+    
     // The level to start on
     int start_level = 0;
     if (argc == 2) {
         start_level = atoi(argv[1]);
     }
-
+    
     struct Game_Code game_code;
     load_game_code(&game_code);
-
+    
     struct Memory persistent_memory, transient_memory;
     make_memory(&persistent_memory, &transient_memory);
-
+    
     // *1.5 in case we add more values at runtime.
     struct Game_State *game_state = arena_alloc(&persistent_memory, 1, (Uint64) (sizeof(struct Game_State)*1.5));
-
+    
     gs = game_state; // This is so that our macros can pick up "gs" instead of game_state.
-
+    
     game_state->persistent_memory = &persistent_memory;
     game_state->transient_memory = &transient_memory;
     
     game_init(game_state);
     game_code.game_init(game_state, start_level);
-
+    
     // Only now, since the levels have been instantiated,
     // can we initialize render targets (since they depend
     // on each level's width/height)
-
+    
     render_targets_init(game_state->renderer, game_state->window_width, game_state->levels, &game_state->textures);
-
+    
     const int reload_delay_max = 5;
     int reload_delay = reload_delay_max; // Frames of delay.
-
+    
     bool running = true;
     
     LARGE_INTEGER time_start, time_elapsed;
-
+    
     LARGE_INTEGER frequency;
     QueryPerformanceFrequency(&frequency);
     QueryPerformanceCounter(&time_start);
-
+    
     const f64 target_seconds_per_frame = 1.0/60.0;
     f64 time_passed = 0.0;
     f32 fps = 0.f;
-
+    
     while (running) {
         LARGE_INTEGER time_elapsed_for_frame;
         QueryPerformanceCounter(&time_elapsed_for_frame);
@@ -263,9 +264,9 @@ int main(int argc, char **argv) {
         }
         
         input_tick(game_state);
-
+        
         SDL_Event event;
-
+        
         bool should_stop = false;
         while (SDL_PollEvent(&event)) {
             bool should_continue = game_code.game_tick_event(game_state, &event);
@@ -273,47 +274,47 @@ int main(int argc, char **argv) {
                 should_stop = true;
             }
         }
-
+        
         game_code.game_run(game_state);
-
+        
         // Zero out the transient memory for next frame!
         ZeroMemory(transient_memory.data, transient_memory.size);
         transient_memory.cursor = transient_memory.data;
-
+        
         if (should_stop) {
             running = false;
         }
-
+        
         QueryPerformanceCounter(&time_elapsed);
-
+        
         Uint64 delta = time_elapsed.QuadPart - time_elapsed_for_frame.QuadPart;
         f64 d = (f64)delta / (f64)frequency.QuadPart;
-
+        
         // Sleep until 16.6ms has passed.
         while (d < target_seconds_per_frame) {
             LARGE_INTEGER end;
             QueryPerformanceCounter(&end);
             d = (f64)(end.QuadPart - time_elapsed_for_frame.QuadPart) / (f64)frequency.QuadPart;
         }
-
+        
         time_passed += d;
-
+        
         // Only update FPS counter every 0.25s.
         if (time_passed > 0.25) {
             fps = 1.0/d;
             time_passed = 0;
         }
-
-
+        
+        
         {
             Uint64 size_current = persistent_memory.cursor - persistent_memory.data;
             Uint64 size_max = persistent_memory.size;
             f32 percentage = (f32)size_current / (f32)size_max;
             percentage *= 100.f;
-
+            
             char title[128] = {0};
             sprintf(title, "Alaska | Memory Used: %.2f%% | FPS: %.2f", percentage, fps);
-
+            
             SDL_SetWindowTitle(game_state->window, title);
         }
     }
diff --git a/src/overlay.c b/src/overlay.c
index ee1908c..c98205f 100644
--- a/src/overlay.c
+++ b/src/overlay.c
@@ -1,11 +1,18 @@
 void overlay_init() {
     struct Overlay *overlay = &gs->overlay;
 
-    overlay->tool = OVERLAY_TOOL_NONE;
+    overlay->tool = OVERLAY_TOOL_BRUSH;
 
     if (overlay->grid == NULL) {
         overlay->grid = arena_alloc(gs->persistent_memory, gs->gw*gs->gh, sizeof(int));
+        overlay->temp_grid = arena_alloc(gs->persistent_memory, gs->gw*gs->gh, sizeof(int));
     }
+
+    overlay->temp_x = -1;
+    overlay->temp_y = -1;
+    overlay->size = 3;
+
+    overlay->r.x = overlay->r.y = -1;
 }
 
 void overlay_set_circle(int x, int y, int r, int value) {
@@ -14,40 +21,208 @@ void overlay_set_circle(int x, int y, int r, int value) {
     for (int yy = -r; yy <= r; yy++) {
         for (int xx = -r; xx <= r; xx++) {
             if (xx*xx + yy*yy > r*r) continue;
+            if (!is_in_bounds(x+xx, y+yy)) continue;
 
             overlay->grid[x+xx+(y+yy)*gs->gw] = value;
         }
     }
 }
 
+void overlay_set_line(int *grid, int x1, int y1, int x2, int y2, int value) {
+    f64 dx = x2-x1;
+    f64 dy = y2-y1;
+    
+    const f64 clamp = 22.5;
+
+    f64 angle = atan2f(dy, dx);
+    angle /= 2 * M_PI;
+    angle *= 360;
+    angle = ((int)angle) % 360;
+    angle = angle / clamp;
+    angle = clamp * round(angle);
+
+    angle /= 360;
+    angle *= 2 * M_PI;
+
+    f64 deg_angle = Degrees(angle);
+
+    f64 len = distancei(x1, y1, x2, y2);
+
+    f64 ux = 0, uy = 0;
+
+    ux = cos(angle);
+    uy = sin(angle);
+    if (is_angle_45(deg_angle) || deg_angle == 90 || deg_angle == 180 || deg_angle == 270 || deg_angle == 0) {
+        ux = round(ux);
+        uy = round(uy);
+    }
+
+    if (is_angle_225(deg_angle)) {
+        ux *= 2;
+        ux = round(ux);
+        ux /= 2.0;
+
+        uy *= 2;
+        uy = round(uy);
+        uy /= 2.0;
+    }
+
+    f64 x = x1;
+    f64 y = y1;
+
+    f64 curr_dist = 0;
+    while (curr_dist < len) {
+        int ix = ceil(x);
+        int iy = ceil(y);
+        grid[ix+iy*gs->gw] = value;
+        x += ux;
+        y += uy;
+            
+        curr_dist = distance(x, y, x1, y1);
+    }
+}
+
+void overlay_flood_fill(int *grid, int x, int y, int value) {
+    if (!is_in_bounds(x, y)) return;
+    if (grid[x+y*gs->gw]) return;
+
+    grid[x+y*gs->gw] = value;
+    
+    overlay_flood_fill(grid, x+1, y, value);
+    overlay_flood_fill(grid, x, y+1, value);
+    overlay_flood_fill(grid, x-1, y, value);
+    overlay_flood_fill(grid, x, y-1, value);
+}
+
+void overlay_set_rectangle(int *grid, SDL_Rect r, int value) {
+    if (r.w < 0) {
+        r.w *= -1;
+        r.x -= r.w;
+    }
+    if (r.h < 0) {
+        r.h *= -1;
+        r.y -= r.h;
+    }
+
+    for (int yy = r.y; yy <= r.y+r.h; yy++) {
+        for (int xx = r.x; xx <= r.x+r.w; xx++) {
+            if (is_in_bounds(xx, yy)) {
+                grid[xx+yy*gs->gw] = value;
+            }
+        }
+    }
+}
+
+void gui_message_stack_push(const char *str);
+
 void overlay_tick() {
     struct Overlay *overlay = &gs->overlay;
 
-    if (gs->input.keys_pressed[SDL_SCANCODE_F9]) {
+    memset(overlay->temp_grid, 0, sizeof(int)*gs->gw*gs->gh);
+
+    if (gs->input.keys_pressed[SDL_SCANCODE_RIGHTBRACKET]) {
+        overlay->size++;
+    } else if (gs->input.keys_pressed[SDL_SCANCODE_LEFTBRACKET]) {
+        overlay->size--;
+    }
+    overlay->size = clamp(overlay->size, 1, 8);
+
+    if (gs->input.keys_pressed[SDL_SCANCODE_F7]) {
+        overlay->tool = OVERLAY_TOOL_RECTANGLE;
+        gui_message_stack_push("Overlay Tool: Rectangle");
+    }
+    if (gs->input.keys_pressed[SDL_SCANCODE_F8]) {
         overlay->tool = OVERLAY_TOOL_BRUSH;
+        gui_message_stack_push("Overlay Tool: Brush");
     }
-    if (gs->input.keys_pressed[SDL_SCANCODE_F10]) {
+    if (gs->input.keys_pressed[SDL_SCANCODE_F9]) {
         overlay->tool = OVERLAY_TOOL_LINE;
+        gui_message_stack_push("Overlay Tool: Line");
+    }
+    if (gs->input.keys_pressed[SDL_SCANCODE_F10]) {
+        if (overlay->tool != OVERLAY_TOOL_ERASER_BRUSH) {
+            overlay->tool = OVERLAY_TOOL_ERASER_BRUSH;
+            gui_message_stack_push("Overlay Tool: Eraser (Brush)");
+        } else {
+            overlay->tool = OVERLAY_TOOL_ERASER_RECTANGLE;
+            gui_message_stack_push("Overlay Tool: Eraser (Rectangle)");
+        }
     }
     if (gs->input.keys_pressed[SDL_SCANCODE_F11]) {
-        overlay->tool = OVERLAY_TOOL_ERASER;
+        overlay->tool = OVERLAY_TOOL_BUCKET;
+        gui_message_stack_push("Overlay Tool: Bucket");
     }
-    if (gs->input.keys_pressed[SDL_SCANCODE_F12]) {
-        overlay->tool = OVERLAY_TOOL_NONE;
+
+    switch (overlay->tool) {
+    case OVERLAY_TOOL_BRUSH: case OVERLAY_TOOL_ERASER_BRUSH: {
+        int value = overlay->tool == OVERLAY_TOOL_BRUSH ? 1 : 0;
+
+        if (gs->input.mouse & SDL_BUTTON(SDL_BUTTON_LEFT)) {
+            overlay_set_circle(gs->input.mx, gs->input.my, overlay->size, value);
+        }
+        break;
     }
+    case OVERLAY_TOOL_RECTANGLE: case OVERLAY_TOOL_ERASER_RECTANGLE: {
+        int value = overlay->tool == OVERLAY_TOOL_RECTANGLE ? 1 : 0;
 
-    if (overlay->tool == OVERLAY_TOOL_NONE) return;
+        if (gs->input.mouse & SDL_BUTTON(SDL_BUTTON_LEFT)) {
+            if (overlay->r.x == -1) {
+                overlay->r.x = gs->input.mx;
+                overlay->r.y = gs->input.my;
+            }
+            overlay->r.w = gs->input.mx - overlay->r.x;
+            overlay->r.h = gs->input.my - overlay->r.y;
 
-    switch (overlay->tool) {
-    case OVERLAY_TOOL_BRUSH:
-        const int r = 3;
+            if (overlay->tool == OVERLAY_TOOL_ERASER_RECTANGLE) {
+                overlay_set_rectangle(overlay->temp_grid, overlay->r, 2);
+            } else {
+                overlay_set_rectangle(overlay->temp_grid, overlay->r, value);
+            }
+        } else {
+            if (overlay->r.x != -1) {
+                overlay_set_rectangle(overlay->grid, overlay->r, value);
+                overlay->r.x = overlay->r.y = -1;
+            }
+        }
+        break;
+    }
+    case OVERLAY_TOOL_LINE: {
         if (gs->input.mouse & SDL_BUTTON(SDL_BUTTON_LEFT)) {
-            overlay_set_circle(gs->input.mx, gs->input.my, r, 1);
-        } else if (gs->input.mouse & SDL_BUTTON(SDL_BUTTON_RIGHT)) {
-            overlay_set_circle(gs->input.mx, gs->input.my, r, 0);
+            if (overlay->temp_x == -1) {
+                overlay->temp_x = gs->input.mx;
+                overlay->temp_y = gs->input.my;
+            }
+
+            overlay_set_line(
+                overlay->temp_grid,
+                overlay->temp_x,
+                overlay->temp_y,
+                gs->input.mx,
+                gs->input.my,
+                1
+            );
+        } else if (gs->input.mouse_released[SDL_BUTTON_LEFT]) {
+            overlay_set_line(
+                overlay->grid,
+                overlay->temp_x,
+                overlay->temp_y,
+                gs->input.mx,
+                gs->input.my,
+                1
+            );
+
+            overlay->temp_x = -1;
+            overlay->temp_y = -1;
         }
         break;
     }
+    case OVERLAY_TOOL_BUCKET: {
+        if (gs->input.mouse_pressed[SDL_BUTTON_LEFT]) {
+            overlay_flood_fill(overlay->grid, gs->input.mx, gs->input.my, 1);
+        }
+        break;
+    }
+    }
 }
 
 void overlay_draw() {
@@ -63,10 +238,17 @@ void overlay_draw() {
     
     for (int y = 0; y < gs->gh; y++) {
         for (int x = 0; x < gs->gw; x++) {
-            if (!overlay->grid[x+y*gs->gw]) continue;
+            if (overlay->temp_grid[x+y*gs->gw] == 2) continue;
+
+            if (!overlay->grid[x+y*gs->gw] && !overlay->temp_grid[x+y*gs->gw]) continue;
 
             SDL_SetRenderDrawColor(gs->renderer, 0, 255, 0, (Uint8)alpha);
             SDL_RenderDrawPoint(gs->renderer, x, y);
         }
     }
+
+    if (gs->current_tool == TOOL_OVERLAY && (overlay->tool == OVERLAY_TOOL_BRUSH || overlay->tool == OVERLAY_TOOL_ERASER_BRUSH)) {
+        SDL_SetRenderDrawColor(gs->renderer, 0, 255, 255, 64);
+        fill_circle(gs->renderer, gs->input.mx, gs->input.my, overlay->size);
+    }
 }
diff --git a/src/overlay.h b/src/overlay.h
index 8c1066f..60997c1 100644
--- a/src/overlay.h
+++ b/src/overlay.h
@@ -1,11 +1,19 @@
 enum Overlay_Tool {
-    OVERLAY_TOOL_NONE,
     OVERLAY_TOOL_BRUSH,
     OVERLAY_TOOL_LINE,
-    OVERLAY_TOOL_ERASER,
+    OVERLAY_TOOL_RECTANGLE,
+    OVERLAY_TOOL_ERASER_BRUSH,
+    OVERLAY_TOOL_ERASER_RECTANGLE,
+    OVERLAY_TOOL_BUCKET,
 };
 
 struct Overlay {
     int *grid;
+    int *temp_grid;
     enum Overlay_Tool tool;
+
+    SDL_Rect r;
+    int size;
+
+    int temp_x, temp_y;
 };
diff --git a/src/shared.h b/src/shared.h
index f6dda8e..3859c1a 100644
--- a/src/shared.h
+++ b/src/shared.h
@@ -77,8 +77,6 @@ struct Game_State {
     int frames;
     bool step_one;
     
-    struct Blob_Hammer blob_hammer;
-    struct Knife knife;
     struct Deleter deleter;
     struct Overlay overlay;
     
@@ -153,7 +151,7 @@ inline void _assert(bool condition, SDL_Window *window, const char *func, const
 }
 
 // Gives pointer to zeroed memory.
-inline void *_arena_alloc(struct Memory *memory, Uint64 num, Uint64 size_individual, const char *file, int line) {
+inline allocator void *_arena_alloc(struct Memory *memory, Uint64 num, Uint64 size_individual, const char *file, int line) {
     Uint64 size;
     void *output = NULL;
 
diff --git a/src/typedefs.h b/src/typedefs.h
index 4789065..c51e775 100644
--- a/src/typedefs.h
+++ b/src/typedefs.h
@@ -1,4 +1,3 @@
-#define persist static
 #define export __declspec(dllexport)
 #define allocator __declspec(allocator)
 
diff --git a/src/util.c b/src/util.c
index bbfac86..0aa29b7 100644
--- a/src/util.c
+++ b/src/util.c
@@ -1,6 +1,30 @@
 #define Radians(x) ((x) * (M_PI / 180.0))
 #define Degrees(x) ((x) * (180.0 / M_PI))
 
+bool is_angle_225(f64 deg_angle) {
+    f64 f = fabs(deg_angle);
+    if (f == 22.5 || f == 157.5 || f == 112.5 || f == 67.5) {
+        return true;
+    }
+    return false;
+}
+
+bool is_angle_45(f64 deg_angle) {
+    f64 f = fabs(deg_angle);
+    if (f == 45 || f == 135 || f == 225 || f == 315) {
+        return true;
+    }
+    return false;
+}
+
+bool is_in_bounds(int x, int y) {
+    return x >= 0 && y >= 0 && x < gs->gw && y < gs->gh;
+}
+
+bool is_in_boundsf(f32 x, f32 y) {
+    return is_in_bounds((int)x, (int)y);
+}
+
 void start_timer() {
     gs->global_start = clock();
 }
@@ -19,27 +43,36 @@ void move_mouse_to_grid_position(f32 x, f32 y) {
 void get_filename_from_type(int type, char *out) {
     switch (type) {
     case CELL_NONE:        strcpy(out, "nothing"); break;
-    case CELL_MARBLE:      strcpy(out, RES_DIR "/items/marble.png"); break;
-    case CELL_COBBLESTONE: strcpy(out, RES_DIR "/items/cobblestone.png"); break;
-    case CELL_QUARTZ:      strcpy(out, RES_DIR "/items/quartz.png"); break;
-    case CELL_GRANITE:     strcpy(out, RES_DIR "/items/quartz.png"); break;
-    case CELL_BASALT:      strcpy(out, RES_DIR "/items/quartz.png"); break;
-    case CELL_WOOD_LOG:    strcpy(out, RES_DIR "/items/wood_log.png"); break;
-    case CELL_WOOD_PLANK:  strcpy(out, RES_DIR "/items/wood_plank.png"); break;
     case CELL_DIRT:        strcpy(out, RES_DIR "/items/dirt.png"); break;
     case CELL_SAND:        strcpy(out, RES_DIR "/items/sand.png"); break;
-    case CELL_GLASS:       strcpy(out, RES_DIR "/items/glass.png"); break;
+        
     case CELL_WATER:       strcpy(out, RES_DIR "/items/water.png"); break;
-
-    case CELL_UNREFINED_COAL: strcpy(out, RES_DIR "/items/coal.png"); break;
-    case CELL_REFINED_COAL:   strcpy(out, RES_DIR "/items/coal.png"); break;
-
+    case CELL_ICE:         strcpy(out, RES_DIR "/items/ice.png"); break;
     case CELL_STEAM:       strcpy(out, RES_DIR "/items/steam.png"); break;
+    
+    case CELL_WOOD_LOG:    strcpy(out, RES_DIR "/items/wood_log.png"); break;
+    case CELL_WOOD_PLANK:  strcpy(out, RES_DIR "/items/wood_plank.png"); break;
+    
+    case CELL_COBBLESTONE: strcpy(out, RES_DIR "/items/cobblestone.png"); break;
+    case CELL_MARBLE:      strcpy(out, RES_DIR "/items/marble.png"); break;
+    case CELL_SANDSTONE:   strcpy(out, RES_DIR "/items/sandstone.png"); break;
+    
+    case CELL_CEMENT:      strcpy(out, RES_DIR "/items/cement.png"); break;
+    case CELL_CONCRETE:    strcpy(out, RES_DIR "/items/concrete.png"); break;
+    
+    case CELL_QUARTZ:      strcpy(out, RES_DIR "/items/quartz.png"); break;
+    case CELL_GLASS:       strcpy(out, RES_DIR "/items/glass.png"); break;
+    
+    case CELL_GRANITE:     strcpy(out, RES_DIR "/items/granite.png"); break;
+    case CELL_BASALT:      strcpy(out, RES_DIR "/items/basalt.png"); break;
     case CELL_DIAMOND:     strcpy(out, RES_DIR "/items/diamond.png"); break;
-    case CELL_ICE:         strcpy(out, RES_DIR "/items/ice.png"); break;
+    
+    case CELL_UNREFINED_COAL: strcpy(out, RES_DIR "/items/coal.png"); break;
+    case CELL_REFINED_COAL:   strcpy(out, RES_DIR "/items/coal.png"); break;
+    case CELL_LAVA:           strcpy(out, RES_DIR "/items/lava.png"); break;
+    
     case CELL_SMOKE:       strcpy(out, RES_DIR "/items/smoke.png"); break;
     case CELL_DUST:        strcpy(out, RES_DIR "/items/dust.png"); break;
-    case CELL_LAVA:        strcpy(out, RES_DIR "/items/quartz.png"); break;
     }
 }
 
@@ -85,9 +118,8 @@ void get_name_from_tool(int type, char *out) {
     case TOOL_CHISEL_SMALL:  strcpy(out, "Small Chisel"); break;
     case TOOL_CHISEL_MEDIUM: strcpy(out, "Medium Chisel"); break;
     case TOOL_CHISEL_LARGE:  strcpy(out, "Large Chisel"); break;
-    case TOOL_KNIFE:         strcpy(out, "Knife"); break;
+    case TOOL_OVERLAY:       strcpy(out, "Overlay"); break;
     case TOOL_DELETER:       strcpy(out, "Deleter"); break;
-    case TOOL_HAMMER:        strcpy(out, "Hammer"); break;
     case TOOL_PLACER:        strcpy(out, "Placer"); break;
     case TOOL_GRABBER:       strcpy(out, "Grabber"); break;
     }
@@ -98,9 +130,8 @@ void get_file_from_tool(int type, char *out) {
     case TOOL_CHISEL_SMALL:  strcpy(out, "chisel_small.png"); break;
     case TOOL_CHISEL_MEDIUM: strcpy(out, "chisel_medium.png"); break;
     case TOOL_CHISEL_LARGE:  strcpy(out, "chisel_large.png"); break;
-    case TOOL_KNIFE:         strcpy(out, "knife.png"); break;
+    case TOOL_OVERLAY:       strcpy(out, "overlay.png"); break;
     case TOOL_DELETER:       strcpy(out, "deleter.png"); break;
-    case TOOL_HAMMER:        strcpy(out, "hammer.png"); break;
     case TOOL_PLACER:        strcpy(out, "placer.png"); break;
     case TOOL_GRABBER:       strcpy(out, "pointer.png"); break;
     }
@@ -241,13 +272,13 @@ bool is_point_in_triangle(SDL_Point pt, SDL_Point v1, SDL_Point v2, SDL_Point v3
     return !(has_neg && has_pos);
 }
 
-void draw_text(TTF_Font *font, const char *str, SDL_Color col, int align_left, int align_bottom, int x, int y, int *out_w, int *out_h) {
+void draw_text(TTF_Font *font, const char *str, SDL_Color col, bool align_left, bool align_bottom, int x, int y, int *out_w, int *out_h) {
     SDL_Surface *surf = TTF_RenderText_Blended(font, str, col);
     SDL_Texture *texture = SDL_CreateTextureFromSurface(gs->renderer, surf);
             
     SDL_Rect dst = { x, y, surf->w, surf->h };
 
-    if (align_left) dst.x -= surf->w;
+    if (!align_left) dst.x -= surf->w;
     if (align_bottom) dst.y -= surf->h;
 
     if (out_w)
@@ -272,3 +303,15 @@ void fill_circle(SDL_Renderer *renderer, int x, int y, int size) {
         }
     }
 }
+
+void fill_circle_in_buffer(int *buffer, int value, int x, int y, int w, int h, int size) {
+    for (int yy = -size; yy <= size; yy++) {
+        for (int xx = -size; xx <= size; xx++) {
+            if (xx*xx + yy*yy > size*size) continue;
+            if (x+xx < 0 || x+xx >= w) continue;
+            if (y+yy < 0 || y+yy >= h) continue;
+
+            buffer[x+xx+(y+yy)*w] = value;
+        }
+    }
+}
diff --git a/todo.txt b/todo.txt
index fb05020..89c1437 100644
--- a/todo.txt
+++ b/todo.txt
@@ -1,15 +1,19 @@
       --------------------------TODO----------------------------
 
-- Create drawable highlight to overlay. Purely aesthetic,
+x Create drawable highlight to overlay. Purely aesthetic,
   but helps the player with creating shapes. Perhaps add
   a red highlight whenever your chisel is in a space where,
   if you click, it will delete some cells that are a part
   of the highlight.
-     - Brush tool
-     - Line tool
-     - Rectangle tool
-     - Circle tool
-     - Eraser tool (circle & rectangle)
+     x Brush tool
+     x Line tool
+     x Rectangle tool
+     x Fill tool
+     x Circle tool
+     x Eraser tool (circle & rectangle)
+        x Circle
+        x Rectangle
+     x Modifying sizes
 
      Essentially, your workflow would consist of getting
      the material in place, then drawing the shape of 
